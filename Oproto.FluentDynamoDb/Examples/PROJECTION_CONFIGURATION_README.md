# Projection Configuration Guide

This guide explains how to configure DynamoDB projections in Oproto.FluentDynamoDb, both manually and through source generation.

## Table of Contents

1. [Overview](#overview)
2. [Manual Configuration](#manual-configuration)
3. [Precedence Rules](#precedence-rules)
4. [Best Practices](#best-practices)
5. [Examples](#examples)

## Overview

Projections in DynamoDB allow you to fetch only specific attributes from items, reducing data transfer and costs. Oproto.FluentDynamoDb supports projections through:

1. **Manual Configuration**: Explicitly configure projections in your code
2. **Source Generation**: Automatically generate projections from projection model classes
3. **Hybrid Approach**: Combine manual and generated projections

## Manual Configuration

Manual configuration is useful when:
- You're not using source generation
- You need runtime control over projections
- You want to override generated projections

### Non-Generic Index with Projection

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Index with automatic projection
    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this,
        "StatusIndex",
        "id, amount, status, created_date");
}

// Usage
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();
// Fetches only: id, amount, status, created_date
```

### Generic Index with Type-Safe Projection

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Generic index with type safety
    public DynamoDbIndex<TransactionSummary> StatusIndex => 
        new DynamoDbIndex<TransactionSummary>(
            this,
            "StatusIndex",
            "id, amount, status, created_date");
}

// Usage with default type
var summaries = await table.StatusIndex.Query<TransactionSummary>()
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ToListAsync();
// Returns List<TransactionSummary>

// Usage with type override
var transactions = await table.StatusIndex.QueryAsync<Transaction>(q => 
    q.Where("status = :status").WithValue(":status", "ACTIVE"));
// Returns List<Transaction>
```

### Index Without Projection

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Index without projection (fetches all fields)
    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this,
        "StatusIndex");
}

// Usage
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();
// Fetches all fields
```

## Precedence Rules

Projections follow a clear precedence order, from highest to lowest:

### 1. Manual `.WithProjection()` Call (Highest Precedence)

Explicit projection in the query builder **always** takes precedence over all other configurations.

```csharp
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .WithProjection("id") // Overrides everything
    .ExecuteAsync();
// Fetches only: id
```

**Use when:**
- You need a one-off projection for a specific query
- You want to override the default projection
- You need to fetch additional or fewer fields than usual

### 2. Index Constructor Projection (Second Precedence)

Projection configured when creating the `DynamoDbIndex` instance is automatically applied to all queries through that index.

```csharp
public DynamoDbIndex StatusIndex => new DynamoDbIndex(
    this,
    "StatusIndex",
    "id, amount, status"); // Applied to all queries

var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();
// Fetches: id, amount, status
```

**Use when:**
- You want consistent projections across all queries to an index
- You want to optimize costs by limiting data transfer at the index level
- You want sensible defaults that can be overridden when needed

### 3. Generated Projection from Source Generator (Third Precedence)

When using `ToListAsync<TProjection>` where `TProjection` is a projection model generated by the source generator, the projection is automatically applied.

```csharp
// With source generation
[DynamoDbProjection(typeof(Transaction))]
public partial class TransactionSummary
{
    public string Id { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; }
}

// Usage
var summaries = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ToListAsync<TransactionSummary>();
// Automatically fetches: id, amount, status
```

**Use when:**
- You're using source generation
- You want type-safe projections
- You want automatic projection based on the result type

### 4. No Projection (Lowest Precedence)

If no projection is configured, all attributes are fetched (default DynamoDB behavior).

```csharp
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();
// Fetches all fields
```

**Use when:**
- You need all attributes
- You're not concerned about data transfer costs
- You're doing a one-time query or export

## Best Practices

### 1. Use Index-Level Projections for Consistent Defaults

Set sensible default projections at the index level to ensure consistency across queries.

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Default projection for most queries
    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this,
        "StatusIndex",
        "id, amount, status, created_date");
}
```

### 2. Use Manual `.WithProjection()` for Exceptional Cases

Reserve manual projections for queries that need different data than the index default.

```csharp
// Most queries use the index default
var standard = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();

// Exceptional case: need additional fields
var detailed = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .WithProjection("id, amount, status, created_date, description, metadata")
    .ExecuteAsync();
```

### 3. Provide Multiple Index Properties for Different Use Cases

Create multiple index properties with different projection levels for different scenarios.

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Minimal projection for list views
    public DynamoDbIndex StatusIndexMinimal => new DynamoDbIndex(
        this,
        "StatusIndex",
        "id, status");

    // Standard projection for most queries
    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this,
        "StatusIndex",
        "id, amount, status, created_date");

    // Full projection (all fields)
    public DynamoDbIndex StatusIndexFull => new DynamoDbIndex(
        this,
        "StatusIndex");
}

// Usage
var listItems = await table.StatusIndexMinimal.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .Take(100)
    .ExecuteAsync();
```

### 4. Document Your Projections

Make it clear which projections are defaults and which can be overridden.

```csharp
/// <summary>
/// StatusIndex with standard projection for most queries.
/// Fetches: id, amount, status, created_date
/// Override with .WithProjection() if you need different fields.
/// </summary>
public DynamoDbIndex StatusIndex => new DynamoDbIndex(
    this,
    "StatusIndex",
    "id, amount, status, created_date");
```

### 5. Use Source Generation for Type Safety

When possible, use source generation with projection models for type-safe queries.

```csharp
// Define projection model
[DynamoDbProjection(typeof(Transaction))]
public partial class TransactionSummary
{
    public string Id { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; }
}

// Type-safe query with automatic projection
var summaries = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ToListAsync<TransactionSummary>();
```

## Examples

### Example 1: Basic Manual Configuration

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this,
        "StatusIndex",
        "id, amount, status");
}

// Query with automatic projection
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ExecuteAsync();
// Fetches: id, amount, status
```

### Example 2: Manual Override

```csharp
// Override automatic projection
var response = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .WithProjection("id") // Overrides index projection
    .ExecuteAsync();
// Fetches: id
```

### Example 3: Generic Index with Type Override

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    public DynamoDbIndex<TransactionSummary> StatusIndex => 
        new DynamoDbIndex<TransactionSummary>(
            this,
            "StatusIndex",
            "id, amount, status");
}

// Query with default type
var summaries = await table.StatusIndex.QueryAsync(q => 
    q.Where("status = :status").WithValue(":status", "ACTIVE"));
// Returns List<TransactionSummary>

// Query with type override
var transactions = await table.StatusIndex.QueryAsync<Transaction>(q => 
    q.Where("status = :status").WithValue(":status", "ACTIVE"));
// Returns List<Transaction>
```

### Example 4: Conditional Projections

```csharp
public static async Task QueryWithConditionalProjection(
    TransactionsTable table,
    bool includeMetadata)
{
    var query = table.StatusIndex.Query
        .Where("status = :status")
        .WithValue(":status", "ACTIVE");

    // Conditionally override projection
    if (includeMetadata)
    {
        query = query.WithProjection("id, amount, status, metadata");
    }
    // Otherwise, use index default projection

    var response = await query.ExecuteAsync();
}
```

### Example 5: Multiple Projection Levels

```csharp
public class TransactionsTable : DynamoDbTableBase
{
    public TransactionsTable(IAmazonDynamoDB client) : base(client, "Transactions")
    {
    }

    // Minimal for list views
    public DynamoDbIndex StatusIndexMinimal => new DynamoDbIndex(
        this, "StatusIndex", "id, status");

    // Standard for most queries
    public DynamoDbIndex StatusIndex => new DynamoDbIndex(
        this, "StatusIndex", "id, amount, status, created_date");

    // Full for detail views
    public DynamoDbIndex StatusIndexFull => new DynamoDbIndex(
        this, "StatusIndex");
}

// Use appropriate index for each scenario
var listItems = await table.StatusIndexMinimal.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .Take(100)
    .ExecuteAsync();

var detailItem = await table.StatusIndexFull.Query
    .Where("status = :status AND id = :id")
    .WithValue(":status", "ACTIVE")
    .WithValue(":id", "TXN123")
    .ExecuteAsync();
```

## Migration Path

### From No Projections to Manual Configuration

```csharp
// Before: No projection
public DynamoDbIndex StatusIndex => new DynamoDbIndex(this, "StatusIndex");

// After: Manual projection
public DynamoDbIndex StatusIndex => new DynamoDbIndex(
    this,
    "StatusIndex",
    "id, amount, status, created_date");
```

### From Manual Configuration to Source Generation

```csharp
// Phase 1: Manual configuration
public DynamoDbIndex StatusIndex => new DynamoDbIndex(
    this,
    "StatusIndex",
    "id, amount, status, created_date");

// Phase 2: Add projection model (source generation)
[DynamoDbProjection(typeof(Transaction))]
public partial class TransactionSummary
{
    public string Id { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; }
    public DateTime CreatedDate { get; set; }
}

// Phase 3: Use projection model (manual projection still works as fallback)
var summaries = await table.StatusIndex.Query
    .Where("status = :status")
    .WithValue(":status", "ACTIVE")
    .ToListAsync<TransactionSummary>();

// Phase 4: Remove manual projection, rely on generated
public DynamoDbIndex StatusIndex => new DynamoDbIndex(this, "StatusIndex");
```

## Summary

- **Manual `.WithProjection()`**: Highest precedence, use for one-off queries
- **Index Constructor Projection**: Second precedence, use for consistent defaults
- **Generated Projection**: Third precedence, use for type-safe queries
- **No Projection**: Lowest precedence, fetches all fields

Choose the approach that best fits your needs:
- **Manual Configuration**: Maximum flexibility, runtime control
- **Source Generation**: Type safety, automatic projection
- **Hybrid**: Combine both for the best of both worlds

For more examples, see:
- `ManualProjectionConfiguration.cs` - Manual configuration examples
- `ProjectionPrecedenceRules.cs` - Detailed precedence rules and scenarios
