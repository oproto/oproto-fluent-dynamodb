using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Oproto.FluentDynamoDb.SourceGenerator;
using Oproto.FluentDynamoDb.SourceGenerator.UnitTests.TestHelpers;
using Oproto.FluentDynamoDb.SourceGenerator.UnitTests.Integration;

namespace Oproto.FluentDynamoDb.SourceGenerator.UnitTests.Generators;

/// <summary>
/// Tests for operation method generation in entity accessor classes.
/// Verifies that operation methods (Get, Query, Scan, Put, Delete, Update) are generated
/// correctly with proper visibility modifiers and respect Generate = false configurations.
/// Covers requirement 5 from the table-generation-redesign spec.
/// </summary>
[Trait("Category", "Unit")]
public class OperationMethodGenerationTests
{
    [Fact]
    public void OperationMethods_AllGeneratedByDefault()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // All operations should be generated by default (except Scan which is not currently implemented)
        tableCode.Should().Contain("Get(string pk)",
            "should generate Get operation by default");
        tableCode.Should().Contain("Query()",
            "should generate Query operation by default");
        tableCode.Should().Contain("Put()",
            "should generate Put operation by default");
        tableCode.Should().Contain("Delete(string pk)",
            "should generate Delete operation by default");
        tableCode.Should().Contain("Update(string pk)",
            "should generate Update operation by default");
    }

    [Fact]
    public void OperationMethods_GenerateFalse_SkipsOperation()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Delete, Generate = false)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Delete operation should not be generated
        tableCode.Should().NotContain("Delete(string pk)",
            "should not generate Delete operation when Generate = false");
        
        // Other operations should still be generated
        tableCode.Should().Contain("Get(string pk)",
            "should still generate Get operation");
        tableCode.Should().Contain("Query()",
            "should still generate Query operation");
        tableCode.Should().Contain("Put()",
            "should still generate Put operation");
        tableCode.Should().Contain("Update(string pk)",
            "should still generate Update operation");
    }

    [Fact]
    public void OperationMethods_PublicModifier_GeneratesPublicMethods()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Get, Modifier = AccessModifier.Public)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Get operation should be public
        tableCode.Should().Contain("public GetItemRequestBuilder<Order> Get(string pk)",
            "should generate public Get operation when Modifier = Public");
    }

    [Fact]
    public void OperationMethods_InternalModifier_GeneratesInternalMethods()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Query, Modifier = AccessModifier.Internal)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Query operation should be internal
        tableCode.Should().Contain("internal QueryRequestBuilder<Order> Query()",
            "should generate internal Query operation when Modifier = Internal");
    }

    [Fact]
    public void OperationMethods_ProtectedModifier_GeneratesProtectedMethods()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Put, Modifier = AccessModifier.Protected)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Put operation should be protected
        tableCode.Should().Contain("protected PutItemRequestBuilder<Order> Put()",
            "should generate protected Put operation when Modifier = Protected");
    }

    [Fact]
    public void OperationMethods_PrivateModifier_GeneratesPrivateMethods()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Update, Modifier = AccessModifier.Private)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Update operation should be private
        tableCode.Should().Contain("private OrderUpdateBuilder Update(string pk)",
            "should generate private Update operation with entity-specific builder when Modifier = Private");
    }

    [Fact]
    public void OperationMethods_MultipleAttributes_CombineCorrectly()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Get, Modifier = AccessModifier.Public)]
    [GenerateAccessors(Operations = TableOperation.Query, Modifier = AccessModifier.Internal)]
    [GenerateAccessors(Operations = TableOperation.Put, Modifier = AccessModifier.Protected)]
    [GenerateAccessors(Operations = TableOperation.Delete, Generate = false)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Each operation should have its configured visibility
        tableCode.Should().Contain("public GetItemRequestBuilder<Order> Get(string pk)",
            "should generate public Get operation");
        tableCode.Should().Contain("internal QueryRequestBuilder<Order> Query()",
            "should generate internal Query operation");
        tableCode.Should().Contain("protected PutItemRequestBuilder<Order> Put()",
            "should generate protected Put operation");
        
        // Delete should not be generated
        tableCode.Should().NotContain("Delete(string pk)",
            "should not generate Delete operation when Generate = false");
        
        // Operations not configured should use default (public, except Scan which is not currently implemented)
        tableCode.Should().Contain("public OrderUpdateBuilder Update(string pk)",
            "should generate public Update operation with entity-specific builder (default)");
    }

    [Fact]
    public void OperationMethods_AllFlag_AppliesModifierToAllOperations()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.All, Modifier = AccessModifier.Internal)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // All operations should be internal (except Scan which is not currently implemented)
        tableCode.Should().Contain("internal GetItemRequestBuilder<Order> Get(string pk)",
            "should generate internal Get operation when All flag is used");
        tableCode.Should().Contain("internal QueryRequestBuilder<Order> Query()",
            "should generate internal Query operation when All flag is used");
        tableCode.Should().Contain("internal PutItemRequestBuilder<Order> Put()",
            "should generate internal Put operation when All flag is used");
        tableCode.Should().Contain("internal DeleteItemRequestBuilder<Order> Delete(string pk)",
            "should generate internal Delete operation when All flag is used");
        tableCode.Should().Contain("internal OrderUpdateBuilder Update(string pk)",
            "should generate internal Update operation with entity-specific builder when All flag is used");
    }

    [Fact]
    public void OperationMethods_CombinedFlags_AppliesModifierToSpecifiedOperations()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Get | TableOperation.Query, Modifier = AccessModifier.Internal)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Get and Query should be internal
        tableCode.Should().Contain("internal GetItemRequestBuilder<Order> Get(string pk)",
            "should generate internal Get operation when combined with Query flag");
        tableCode.Should().Contain("internal QueryRequestBuilder<Order> Query()",
            "should generate internal Query operation when combined with Get flag");
        
        // Other operations should be public (default, except Scan which is not currently implemented)
        tableCode.Should().Contain("public PutItemRequestBuilder<Order> Put()",
            "should generate public Put operation (default)");
        tableCode.Should().Contain("public DeleteItemRequestBuilder<Order> Delete(string pk)",
            "should generate public Delete operation (default)");
        tableCode.Should().Contain("public OrderUpdateBuilder Update(string pk)",
            "should generate public Update operation with entity-specific builder (default)");
    }

    [Fact]
    public void OperationMethods_MultipleCombinedFlags_AppliesCorrectly()
    {
        // Arrange - Configure read and write operations separately (excluding Scan which isn't implemented)
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.Get | TableOperation.Query, Modifier = AccessModifier.Internal)]
    [GenerateAccessors(Operations = TableOperation.Put | TableOperation.Update, Modifier = AccessModifier.Protected)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Read operations should be internal
        tableCode.Should().Contain("internal GetItemRequestBuilder<Order> Get(string pk)",
            "should generate internal Get operation");
        tableCode.Should().Contain("internal QueryRequestBuilder<Order> Query()",
            "should generate internal Query operation");
        
        // Write operations should be protected
        tableCode.Should().Contain("protected PutItemRequestBuilder<Order> Put()",
            "should generate protected Put operation");
        tableCode.Should().Contain("protected OrderUpdateBuilder Update(string pk)",
            "should generate protected Update operation with entity-specific builder");
        
        // Delete should be public (default)
        tableCode.Should().Contain("public DeleteItemRequestBuilder<Order> Delete(string pk)",
            "should generate public Delete operation (default)");
    }

    [Fact]
    public void OperationMethods_AllFlagWithGenerateFalse_SkipsAllOperations()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.All, Generate = false)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // No operations should be generated (checking for operation methods in accessor class)
        var accessorStart = tableCode.IndexOf("public class OrderAccessor");
        var accessorCode = tableCode.Substring(accessorStart);
        
        // Verify no operation methods exist in the accessor (only constructor should be there)
        // We check that the accessor class exists but has minimal content
        accessorCode.Should().Contain("internal OrderAccessor(AppTableTable table)",
            "accessor constructor should still exist");
        
        // Count method declarations - should only have constructor
        var methodCount = System.Text.RegularExpressions.Regex.Matches(
            accessorCode.Substring(0, Math.Min(1000, accessorCode.Length)), 
            @"(public|internal|protected|private)\s+\w+\s+\w+\(").Count;
        
        methodCount.Should().BeLessThanOrEqualTo(1,
            "should have at most the constructor when all operations are disabled");
    }

    [Fact]
    public void OperationMethods_ConflictingConfiguration_EmitsDiagnostic()
    {
        // Arrange - trying to configure Query operation twice should emit error
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.All, Modifier = AccessModifier.Internal)]
    [GenerateAccessors(Operations = TableOperation.Query, Modifier = AccessModifier.Public)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert - should emit FDDB003 diagnostic for conflicting configuration
        result.Diagnostics.Should().Contain(d => 
            d.Severity == DiagnosticSeverity.Error && 
            d.Id == "FDDB003",
            "should emit FDDB003 error when same operation is configured multiple times");
    }

    [Fact]
    public void OperationMethods_MultipleEntities_EachHasOwnConfiguration()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""shared-table"", IsDefault = true)]
    [GenerateAccessors(Operations = TableOperation.All, Modifier = AccessModifier.Public)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }

    [DynamoDbTable(""shared-table"")]
    [GenerateAccessors(Operations = TableOperation.Get | TableOperation.Query, Modifier = AccessModifier.Internal)]
    [GenerateAccessors(Operations = TableOperation.Delete, Generate = false)]
    public partial class OrderLine
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("SharedTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // Order should have all public operations
        var orderAccessorStart = tableCode.IndexOf("public class OrderAccessor");
        var orderLineAccessorStart = tableCode.IndexOf("public class OrderLineAccessor");
        
        orderAccessorStart.Should().BeGreaterThan(0, "should contain OrderAccessor class");
        orderLineAccessorStart.Should().BeGreaterThan(0, "should contain OrderLineAccessor class");
        
        var orderAccessorCode = tableCode.Substring(orderAccessorStart, orderLineAccessorStart - orderAccessorStart);
        
        // Order operations should be public
        orderAccessorCode.Should().Contain("public GetItemRequestBuilder<Order> Get(string pk)",
            "Order should have public Get operation");
        orderAccessorCode.Should().Contain("public QueryRequestBuilder<Order> Query()",
            "Order should have public Query operation");
        
        // OrderLine should have internal Get/Query and no Delete
        var orderLineAccessorCode = tableCode.Substring(orderLineAccessorStart);
        
        orderLineAccessorCode.Should().Contain("internal GetItemRequestBuilder<OrderLine> Get(string pk)",
            "OrderLine should have internal Get operation");
        orderLineAccessorCode.Should().Contain("internal QueryRequestBuilder<OrderLine> Query()",
            "OrderLine should have internal Query operation");
        orderLineAccessorCode.Should().NotContain("Delete(string pk)",
            "OrderLine should not have Delete operation");
    }

    [Fact]
    public void OperationMethods_DefaultBehavior_AllPublic()
    {
        // Arrange
        var source = @"
using System;
using Oproto.FluentDynamoDb.Attributes;

namespace TestNamespace
{
    [DynamoDbTable(""app-table"", IsDefault = true)]
    public partial class Order
    {
        [PartitionKey]
        [DynamoDbAttribute(""pk"")]
        public string Id { get; set; } = string.Empty;
    }
}";

        // Act
        var result = GenerateCode(source);

        // Assert
        result.Diagnostics.Should().NotContain(d => d.Severity == DiagnosticSeverity.Error);
        
        var tableFiles = result.GeneratedSources
            .Where(s => s.FileName.Contains("AppTableTable.g.cs"))
            .ToArray();
        
        tableFiles.Should().HaveCount(1);
        
        var tableCode = tableFiles[0].SourceText.ToString();
        
        // All operations should be public by default (except Scan which is not currently implemented)
        tableCode.Should().Contain("public GetItemRequestBuilder<Order> Get(string pk)",
            "should generate public Get operation by default");
        tableCode.Should().Contain("public QueryRequestBuilder<Order> Query()",
            "should generate public Query operation by default");
        tableCode.Should().Contain("public PutItemRequestBuilder<Order> Put()",
            "should generate public Put operation by default");
        tableCode.Should().Contain("public DeleteItemRequestBuilder<Order> Delete(string pk)",
            "should generate public Delete operation by default");
        tableCode.Should().Contain("public OrderUpdateBuilder Update(string pk)",
            "should generate public Update operation with entity-specific builder by default");
    }

    private static GeneratorTestResult GenerateCode(string source)
    {
        var compilation = CSharpCompilation.Create(
            "TestAssembly",
            new[] {
                CSharpSyntaxTree.ParseText(source)
            },
            new[] {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Collections.Generic.List<>).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Oproto.FluentDynamoDb.Attributes.DynamoDbTableAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Amazon.DynamoDBv2.Model.AttributeValue).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Oproto.FluentDynamoDb.Storage.IDynamoDbEntity).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Linq.Enumerable).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.IO.Stream).Assembly.Location),
                MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "netstandard.dll")),
                MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Collections.dll")),
                MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Linq.Expressions.dll"))
            },
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new DynamoDbSourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        var generatedSources = outputCompilation.SyntaxTrees
            .Skip(compilation.SyntaxTrees.Count())
            .Select(tree => new GeneratedSource(tree.FilePath, tree.GetText()))
            .ToArray();

        return new GeneratorTestResult
        {
            Diagnostics = diagnostics,
            GeneratedSources = generatedSources
        };
    }
}
