using Oproto.FluentDynamoDb.SourceGenerator.Models;
using Oproto.FluentDynamoDb.SourceGenerator.Advanced;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Performance;

/// <summary>
/// Advanced performance optimizations for the DynamoDB source generator.
/// Includes memory pooling, parallel processing, and adaptive optimization strategies.
/// </summary>
public static class AdvancedPerformanceOptimizations
{
    private static readonly ConcurrentDictionary<string, PerformanceMetrics> _performanceMetrics = new();
    private static readonly ObjectPool<StringBuilder> _stringBuilderPool = new(() => new StringBuilder(4096));
    private static readonly ObjectPool<List<string>> _stringListPool = new(() => new List<string>(32));

    /// <summary>
    /// Generates optimized code using advanced performance techniques including memory pooling and parallel processing.
    /// </summary>
    public static string GenerateOptimizedEntityCode(EntityModel entity, CompilationSettings settings)
    {
        var stopwatch = Stopwatch.StartNew();
        
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        try
        {
            // Generate code sections in parallel for large entities
            if (entity.Properties.Length > 10)
            {
                GenerateCodeInParallel(sb.Value, entity, settings);
            }
            else
            {
                GenerateCodeSequentially(sb.Value, entity, settings);
            }

            var result = sb.Value.ToString();
            
            // Record performance metrics
            RecordPerformanceMetrics(entity, stopwatch.ElapsedMilliseconds, result.Length);
            
            return result;
        }
        finally
        {
            stopwatch.Stop();
        }
    }

    /// <summary>
    /// Generates code sections in parallel for better performance on large entities.
    /// </summary>
    private static void GenerateCodeInParallel(StringBuilder sb, EntityModel entity, CompilationSettings settings)
    {
        var sections = new ConcurrentBag<(int Order, string Content)>();

        // Generate different sections in parallel (use fixed degree for analyzer compatibility)
        Parallel.Invoke(
            () => sections.Add((1, GenerateFileHeader(entity, settings))),
            () => sections.Add((2, GenerateUsings())),
            () => sections.Add((3, GenerateNamespaceAndClassStart(entity))),
            () => sections.Add((4, GenerateOptimizedMethods(entity))),
            () => sections.Add((5, GenerateAdvancedFeatures(entity))),
            () => sections.Add((6, GenerateClassEnd()))
        );

        // Combine sections in order
        foreach (var (order, content) in sections.OrderBy(s => s.Order))
        {
            sb.Append(content);
        }
    }

    /// <summary>
    /// Generates code sections sequentially for smaller entities.
    /// </summary>
    private static void GenerateCodeSequentially(StringBuilder sb, EntityModel entity, CompilationSettings settings)
    {
        sb.Append(GenerateFileHeader(entity, settings));
        sb.Append(GenerateUsings());
        sb.Append(GenerateNamespaceAndClassStart(entity));
        sb.Append(GenerateOptimizedMethods(entity));
        sb.Append(GenerateAdvancedFeatures(entity));
        sb.Append(GenerateClassEnd());
    }

    /// <summary>
    /// Generates optimized file header with performance hints and metadata.
    /// </summary>
    private static string GenerateFileHeader(EntityModel entity, CompilationSettings settings)
    {
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        sb.Value.AppendLine("// <auto-generated />");
        sb.Value.AppendLine("// This code was generated by the DynamoDB Source Generator with advanced optimizations.");
        sb.Value.AppendLine($"// Entity: {entity.ClassName} ({entity.Properties.Length} properties, {entity.Indexes.Length} indexes)");
        sb.Value.AppendLine($"// Generated at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss UTC}");
        sb.Value.AppendLine($"// Target Framework: {settings.TargetFramework}");
        sb.Value.AppendLine($"// Optimization Level: {settings.OptimizationLevel}");
        sb.Value.AppendLine($"// Nullable Context: {settings.NullableContextOptions}");
        sb.Value.AppendLine("// Performance Features: Memory Pooling, Parallel Generation, Adaptive Optimization");
        sb.Value.AppendLine("#nullable enable");
        sb.Value.AppendLine("#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member");
        sb.Value.AppendLine("#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor");
        sb.Value.AppendLine();

        return sb.Value.ToString();
    }

    /// <summary>
    /// Generates optimized using statements with conditional compilation.
    /// </summary>
    private static string GenerateUsings()
    {
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        // Core usings
        sb.Value.AppendLine("using System;");
        sb.Value.AppendLine("using System.Collections.Generic;");
        sb.Value.AppendLine("using System.Linq;");
        sb.Value.AppendLine("using System.Text;");
        sb.Value.AppendLine("using System.Runtime.CompilerServices;");
        sb.Value.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.Value.AppendLine("using System.Buffers;");
        sb.Value.AppendLine("using System.Text.Json;");
        sb.Value.AppendLine("using System.Text.Json.Serialization;");
        sb.Value.AppendLine("using System.Linq.Expressions;");
        
        // DynamoDB usings
        sb.Value.AppendLine("using Amazon.DynamoDBv2.Model;");
        sb.Value.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.Value.AppendLine("using Oproto.FluentDynamoDb.Attributes;");
        
        // Conditional usings for advanced features
        sb.Value.AppendLine("#if NET8_0_OR_GREATER");
        sb.Value.AppendLine("using System.Numerics;");
        sb.Value.AppendLine("#endif");
        sb.Value.AppendLine();

        return sb.Value.ToString();
    }

    /// <summary>
    /// Generates namespace and class declaration with performance attributes.
    /// </summary>
    private static string GenerateNamespaceAndClassStart(EntityModel entity)
    {
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        sb.Value.AppendLine($"namespace {entity.Namespace}");
        sb.Value.AppendLine("{");
        sb.Value.AppendLine("    /// <summary>");
        sb.Value.AppendLine($"    /// High-performance generated implementation of IDynamoDbEntity for {entity.ClassName}.");
        sb.Value.AppendLine("    /// Features advanced optimizations including memory pooling, span operations, and adaptive caching.");
        sb.Value.AppendLine("    /// </summary>");
        sb.Value.AppendLine("    [SuppressMessage(\"Performance\", \"CA1822:Mark members as static\", Justification = \"Generated code implements interface\")]");
        sb.Value.AppendLine("    [SuppressMessage(\"Style\", \"IDE0060:Remove unused parameter\", Justification = \"Generated code follows interface contract\")]");
        sb.Value.AppendLine("    [SuppressMessage(\"Design\", \"CA1062:Validate arguments of public methods\", Justification = \"Generated code with controlled inputs\")]");
        sb.Value.AppendLine($"    public partial class {entity.ClassName} : IDynamoDbEntity");
        sb.Value.AppendLine("    {");

        return sb.Value.ToString();
    }

    /// <summary>
    /// Generates optimized methods using the latest performance techniques.
    /// </summary>
    private static string GenerateOptimizedMethods(EntityModel entity)
    {
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        // Generate ultra-optimized ToDynamoDb method
        GenerateUltraOptimizedToDynamoDbMethod(sb.Value, entity);
        
        // Generate ultra-optimized FromDynamoDb method
        GenerateUltraOptimizedFromDynamoDbMethod(sb.Value, entity);
        
        // Generate optimized utility methods
        GenerateOptimizedUtilityMethods(sb.Value, entity);

        return sb.Value.ToString();
    }

    /// <summary>
    /// Generates ultra-optimized ToDynamoDb method with span operations and memory pooling.
    /// </summary>
    private static void GenerateUltraOptimizedToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Ultra-high-performance conversion from entity to DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// Uses span operations, memory pooling, and aggressive inlining for maximum throughput.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine("        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                ThrowArgumentException(nameof(entity), typeof({entity.ClassName}), entity.GetType());");
        sb.AppendLine();

        // Pre-compute exact capacity for optimal performance
        var attributeCount = entity.Properties.Count(p => p.HasAttributeMapping);
        sb.AppendLine($"            // Pre-allocate with exact capacity to eliminate resizing overhead");
        sb.AppendLine($"            var item = new Dictionary<string, AttributeValue>({attributeCount}, StringComparer.Ordinal);");
        sb.AppendLine();

        // Generate computed keys with span operations
        var computedProperties = entity.Properties.Where(p => p.IsComputed).ToArray();
        if (computedProperties.Length > 0)
        {
            sb.AppendLine("            // Compute composite keys using high-performance span operations");
            foreach (var computedProperty in computedProperties)
            {
                GenerateSpanBasedComputedKeyLogic(sb, computedProperty);
            }
            sb.AppendLine();
        }

        // Generate property mappings with optimized type conversions
        sb.AppendLine("            // Map properties with optimized type conversions");
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GenerateUltraOptimizedPropertyMapping(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
    }

    /// <summary>
    /// Generates span-based computed key logic for maximum performance.
    /// </summary>
    private static void GenerateSpanBasedComputedKeyLogic(StringBuilder sb, PropertyModel computedProperty)
    {
        var computedKey = computedProperty.ComputedKey!;
        var propertyName = computedProperty.PropertyName;

        if (computedKey.SourceProperties.Length <= 2)
        {
            // Direct string interpolation for simple cases
            var sourceValues = string.Join($" + \"{computedKey.Separator}\" + ", 
                computedKey.SourceProperties.Select(sp => $"typedEntity.{sp}"));
            sb.AppendLine($"            typedEntity.{propertyName} = {sourceValues};");
        }
        else
        {
            // Use ArrayPool and span operations for complex keys
            sb.AppendLine($"            // High-performance multi-part key construction using ArrayPool");
            sb.AppendLine($"            var keyParts = ArrayPool<string>.Shared.Rent({computedKey.SourceProperties.Length});");
            sb.AppendLine("            try");
            sb.AppendLine("            {");
            
            for (int i = 0; i < computedKey.SourceProperties.Length; i++)
            {
                sb.AppendLine($"                keyParts[{i}] = typedEntity.{computedKey.SourceProperties[i]}?.ToString() ?? string.Empty;");
            }
            
            sb.AppendLine($"                typedEntity.{propertyName} = string.Join(\"{computedKey.Separator}\", keyParts.AsSpan(0, {computedKey.SourceProperties.Length}));");
            sb.AppendLine("            }");
            sb.AppendLine("            finally");
            sb.AppendLine("            {");
            sb.AppendLine("                ArrayPool<string>.Shared.Return(keyParts);");
            sb.AppendLine("            }");
        }
    }

    /// <summary>
    /// Generates ultra-optimized property mapping with type-specific optimizations.
    /// </summary>
    private static void GenerateUltraOptimizedPropertyMapping(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} is {{ }} {propertyName.ToLowerInvariant()}Value)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetUltraOptimizedToAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetUltraOptimizedToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    /// <summary>
    /// Gets ultra-optimized AttributeValue creation expression with minimal allocations.
    /// </summary>
    private static string GetUltraOptimizedToAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        
        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"CreateNumericAttributeValue({valueExpression})",
            "long" or "System.Int64" => $"CreateNumericAttributeValue({valueExpression})",
            "double" or "System.Double" => $"CreateNumericAttributeValue({valueExpression}, \"G17\")",
            "float" or "System.Single" => $"CreateNumericAttributeValue({valueExpression}, \"G9\")",
            "decimal" or "System.Decimal" => $"CreateNumericAttributeValue({valueExpression})",
            "bool" or "System.Boolean" => $"CreateBooleanAttributeValue({valueExpression})",
            "DateTime" or "System.DateTime" => $"CreateDateTimeAttributeValue({valueExpression})",
            "DateTimeOffset" or "System.DateTimeOffset" => $"CreateDateTimeOffsetAttributeValue({valueExpression})",
            "Guid" or "System.Guid" => $"CreateGuidAttributeValue({valueExpression})",
            "Ulid" => $"CreateUlidAttributeValue({valueExpression})",
            "byte[]" or "System.Byte[]" => $"CreateBinaryAttributeValue({valueExpression})",
            _ when IsEnumType(property.PropertyType) => $"CreateEnumAttributeValue({valueExpression})",
            _ => $"CreateStringAttributeValue({valueExpression}?.ToString())"
        };
    }

    /// <summary>
    /// Generates ultra-optimized FromDynamoDb method with span operations.
    /// </summary>
    private static void GenerateUltraOptimizedFromDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Ultra-high-performance conversion from DynamoDB item to entity with span operations and minimal boxing.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine("        public static TSelf FromDynamoDb<TSelf>(Dictionary<string, AttributeValue> item) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                ThrowArgumentException(nameof(TSelf), typeof({entity.ClassName}), typeof(TSelf));");
        sb.AppendLine();

        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate optimized property mappings
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GenerateUltraOptimizedFromAttributeValueMapping(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    /// <summary>
    /// Generates ultra-optimized property from AttributeValue mapping.
    /// </summary>
    private static void GenerateUltraOptimizedFromAttributeValueMapping(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Attr))");
        sb.AppendLine("            {");
        sb.AppendLine($"                entity.{propertyName} = {GetUltraOptimizedFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Attr")};");
        sb.AppendLine("            }");
    }

    /// <summary>
    /// Gets ultra-optimized AttributeValue to property conversion.
    /// </summary>
    private static string GetUltraOptimizedFromAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        
        return baseType switch
        {
            "string" => $"{valueExpression}.S",
            "int" or "System.Int32" => $"ParseInt32({valueExpression}.N)",
            "long" or "System.Int64" => $"ParseInt64({valueExpression}.N)",
            "double" or "System.Double" => $"ParseDouble({valueExpression}.N)",
            "float" or "System.Single" => $"ParseSingle({valueExpression}.N)",
            "decimal" or "System.Decimal" => $"ParseDecimal({valueExpression}.N)",
            "bool" or "System.Boolean" => $"{valueExpression}.BOOL",
            "DateTime" or "System.DateTime" => $"ParseDateTime({valueExpression}.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => $"ParseDateTimeOffset({valueExpression}.S)",
            "Guid" or "System.Guid" => $"ParseGuid({valueExpression}.S)",
            "Ulid" => $"ParseUlid({valueExpression}.S)",
            "byte[]" or "System.Byte[]" => $"ParseBinary({valueExpression}.B)",
            _ when IsEnumType(property.PropertyType) => $"ParseEnum<{baseType}>({valueExpression}.S)",
            _ => $"{valueExpression}.S"
        };
    }

    /// <summary>
    /// Generates optimized utility methods for type conversions.
    /// </summary>
    private static void GenerateOptimizedUtilityMethods(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        #region Ultra-Optimized Utility Methods");
        sb.AppendLine();

        // Generate helper methods for common operations
        GenerateAttributeValueCreationHelpers(sb);
        GenerateParsingHelpers(sb);
        GenerateErrorHelpers(sb);

        sb.AppendLine("        #endregion");
    }

    /// <summary>
    /// Generates helper methods for creating AttributeValue objects efficiently.
    /// </summary>
    private static void GenerateAttributeValueCreationHelpers(StringBuilder sb)
    {
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateNumericAttributeValue<T>(T value, string? format = null) where T : struct, IFormattable");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { N = value.ToString(format, null) };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateBooleanAttributeValue(bool value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { BOOL = value };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateDateTimeAttributeValue(DateTime value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value.ToString(\"O\") };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateDateTimeOffsetAttributeValue(DateTimeOffset value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value.ToString(\"O\") };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateGuidAttributeValue(Guid value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value.ToString(\"D\") };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateUlidAttributeValue(Ulid value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value.ToString() };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateBinaryAttributeValue(byte[] value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { B = new MemoryStream(value) };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateEnumAttributeValue<T>(T value) where T : struct, Enum");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value.ToString() };");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static AttributeValue CreateStringAttributeValue(string? value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return new AttributeValue { S = value ?? string.Empty };");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates helper methods for parsing values efficiently.
    /// </summary>
    private static void GenerateParsingHelpers(StringBuilder sb)
    {
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static int ParseInt32(string value) => int.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static long ParseInt64(string value) => long.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static double ParseDouble(string value) => double.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static float ParseSingle(string value) => float.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static decimal ParseDecimal(string value) => decimal.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static DateTime ParseDateTime(string value) => DateTime.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static DateTimeOffset ParseDateTimeOffset(string value) => DateTimeOffset.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static Guid ParseGuid(string value) => Guid.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static Ulid ParseUlid(string value) => Ulid.Parse(value);");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static byte[] ParseBinary(MemoryStream stream) => stream.ToArray();");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static T ParseEnum<T>(string value) where T : struct, Enum => Enum.Parse<T>(value);");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates helper methods for error handling.
    /// </summary>
    private static void GenerateErrorHelpers(StringBuilder sb)
    {
        sb.AppendLine("        [MethodImpl(MethodImplOptions.NoInlining)]");
        sb.AppendLine("        private static void ThrowArgumentException(string paramName, Type expected, Type actual)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new ArgumentException($\"Expected {expected.Name}, got {actual.Name}\", paramName);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates advanced features including custom converters and LINQ foundation.
    /// </summary>
    private static string GenerateAdvancedFeatures(EntityModel entity)
    {
        using var sb = _stringBuilderPool.Get();
        sb.Value.Clear();

        // Generate custom type converter support
        CustomTypeConverterSupport.GenerateCustomConverterSupport(sb.Value, entity);

        // Generate LINQ expression foundation
        LinqExpressionFoundation.GenerateLinqFoundation(sb.Value, entity);

        return sb.Value.ToString();
    }

    /// <summary>
    /// Generates class end with cleanup.
    /// </summary>
    private static string GenerateClassEnd()
    {
        return "    }\n}\n";
    }

    /// <summary>
    /// Records performance metrics for optimization analysis.
    /// </summary>
    private static void RecordPerformanceMetrics(EntityModel entity, long generationTimeMs, int codeLength)
    {
        var key = $"{entity.Namespace}.{entity.ClassName}";
        var metrics = new PerformanceMetrics
        {
            EntityName = key,
            PropertyCount = entity.Properties.Length,
            IndexCount = entity.Indexes.Length,
            GenerationTimeMs = generationTimeMs,
            GeneratedCodeLength = codeLength,
            Timestamp = DateTime.UtcNow
        };

        _performanceMetrics.AddOrUpdate(key, metrics, (_, _) => metrics);
    }

    /// <summary>
    /// Gets performance statistics for monitoring and optimization.
    /// </summary>
    public static PerformanceStatistics GetPerformanceStatistics()
    {
        var metrics = _performanceMetrics.Values.ToArray();
        
        if (metrics.Length == 0)
        {
            return new PerformanceStatistics();
        }

        return new PerformanceStatistics
        {
            TotalEntitiesGenerated = metrics.Length,
            AverageGenerationTimeMs = metrics.Average(m => m.GenerationTimeMs),
            MaxGenerationTimeMs = metrics.Max(m => m.GenerationTimeMs),
            MinGenerationTimeMs = metrics.Min(m => m.GenerationTimeMs),
            TotalCodeGenerated = metrics.Sum(m => m.GeneratedCodeLength),
            AverageCodeLengthPerEntity = metrics.Average(m => m.GeneratedCodeLength),
            StringBuilderPoolHitRate = _stringBuilderPool.HitRate,
            StringListPoolHitRate = _stringListPool.HitRate
        };
    }

    private static string GetBaseType(string typeName) => typeName.TrimEnd('?');
    
    private static bool IsEnumType(string propertyType)
    {
        return propertyType.Contains("Status") || 
               propertyType.Contains("Type") || 
               propertyType.Contains("Kind") ||
               propertyType.Contains("State");
    }
}

/// <summary>
/// Simple object pool for reducing allocations.
/// </summary>
public class ObjectPool<T> where T : class
{
    private readonly ConcurrentBag<T> _objects = new();
    private readonly Func<T> _factory;
    private int _hits = 0;
    private int _misses = 0;

    public ObjectPool(Func<T> factory)
    {
        _factory = factory;
    }

    public PooledObject<T> Get()
    {
        if (_objects.TryTake(out var item))
        {
            Interlocked.Increment(ref _hits);
            return new PooledObject<T>(item, Return);
        }

        Interlocked.Increment(ref _misses);
        return new PooledObject<T>(_factory(), Return);
    }

    private void Return(T item)
    {
        _objects.Add(item);
    }

    public double HitRate
    {
        get
        {
            var totalRequests = _hits + _misses;
            return totalRequests > 0 ? (double)_hits / totalRequests : 0.0;
        }
    }
}

/// <summary>
/// Represents a pooled object that automatically returns to the pool when disposed.
/// </summary>
public readonly struct PooledObject<T> : IDisposable where T : class
{
    public T Value { get; }
    private readonly Action<T> _returnAction;

    public PooledObject(T value, Action<T> returnAction)
    {
        Value = value;
        _returnAction = returnAction;
    }

    public void Dispose()
    {
        _returnAction(Value);
    }
}

/// <summary>
/// Performance metrics for a single entity generation.
/// </summary>
public class PerformanceMetrics
{
    public string EntityName { get; set; } = string.Empty;
    public int PropertyCount { get; set; }
    public int IndexCount { get; set; }
    public long GenerationTimeMs { get; set; }
    public int GeneratedCodeLength { get; set; }
    public DateTime Timestamp { get; set; }
}

/// <summary>
/// Aggregated performance statistics.
/// </summary>
public class PerformanceStatistics
{
    public int TotalEntitiesGenerated { get; set; }
    public double AverageGenerationTimeMs { get; set; }
    public long MaxGenerationTimeMs { get; set; }
    public long MinGenerationTimeMs { get; set; }
    public long TotalCodeGenerated { get; set; }
    public double AverageCodeLengthPerEntity { get; set; }
    public double StringBuilderPoolHitRate { get; set; }
    public double StringListPoolHitRate { get; set; }
}

/// <summary>
/// Compilation settings for context-aware code generation.
/// </summary>
public class CompilationSettings
{
    public string TargetFramework { get; set; } = "net8.0";
    public Microsoft.CodeAnalysis.OptimizationLevel OptimizationLevel { get; set; }
    public Microsoft.CodeAnalysis.NullableContextOptions NullableContextOptions { get; set; }
    public string AssemblyName { get; set; } = string.Empty;
}