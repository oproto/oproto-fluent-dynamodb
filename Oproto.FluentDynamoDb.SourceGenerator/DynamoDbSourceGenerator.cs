using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;

namespace Oproto.FluentDynamoDb.SourceGenerator;

/// <summary>
/// Source generator for DynamoDB entity mapping code, field constants, and key builders.
/// </summary>
[Generator]
public class DynamoDbSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register syntax receiver for classes with DynamoDbTable attribute
        var entityClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsDynamoDbEntity(s),
                transform: static (ctx, _) => GetEntityInfo(ctx))
            .Where(static m => m is not null);

        // Register code generation
        context.RegisterSourceOutput(entityClasses.Collect(), Execute);
    }

    private static bool IsDynamoDbEntity(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.AttributeLists.Any(al =>
                   al.Attributes.Any(a =>
                       a.Name.ToString().Contains("DynamoDbTable")));
    }

    private static EntityInfo? GetEntityInfo(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax classDecl)
            return null;

        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        
        if (classSymbol == null)
            return null;

        // Basic entity info extraction - will be expanded in later tasks
        return new EntityInfo
        {
            ClassName = classSymbol.Name,
            Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
            ClassDeclaration = classDecl
        };
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<EntityInfo?> entities)
    {
        foreach (var entity in entities)
        {
            if (entity == null) continue;

            // Generate placeholder implementation - will be expanded in later tasks
            var sourceCode = GenerateEntityImplementation(entity);
            context.AddSource($"{entity.ClassName}.g.cs", sourceCode);
        }
    }

    private static string GenerateEntityImplementation(EntityInfo entity)
    {
        return $@"// <auto-generated />
#nullable enable

namespace {entity.Namespace}
{{
    // Placeholder implementation for {entity.ClassName}
    // Full implementation will be added in subsequent tasks
    public partial class {entity.ClassName}
    {{
        // Source generator infrastructure is ready
        // Entity mapping, field constants, and key builders will be generated here
    }}
}}";
    }
}

/// <summary>
/// Basic entity information extracted from syntax analysis.
/// </summary>
internal class EntityInfo
{
    public string ClassName { get; set; } = string.Empty;
    public string Namespace { get; set; } = string.Empty;
    public ClassDeclarationSyntax? ClassDeclaration { get; set; }
}