using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Oproto.FluentDynamoDb.SourceGenerator.Analysis;
using Oproto.FluentDynamoDb.SourceGenerator.Generators;
using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Collections.Immutable;

namespace Oproto.FluentDynamoDb.SourceGenerator;

/// <summary>
/// Source generator for DynamoDB entity mapping code, field constants, and key builders.
/// </summary>
[Generator]
public class DynamoDbSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register syntax receiver for classes with DynamoDbTable attribute
        var entityClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsDynamoDbEntity(s),
                transform: static (ctx, _) => GetEntityModel(ctx))
            .Where(static m => m.Model is not null);

        // Register code generation
        context.RegisterSourceOutput(entityClasses.Collect(), Execute);
    }

    private static bool IsDynamoDbEntity(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.AttributeLists.Any(al =>
                   al.Attributes.Any(a =>
                       a.Name.ToString().Contains("DynamoDbTable")));
    }

    private static (EntityModel? Model, IReadOnlyList<Diagnostic> Diagnostics) GetEntityModel(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax classDecl)
            return (null, Array.Empty<Diagnostic>());

        var analyzer = new EntityAnalyzer();
        var entityModel = analyzer.AnalyzeEntity(classDecl, context.SemanticModel);

        return (entityModel, analyzer.Diagnostics);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<(EntityModel? Model, IReadOnlyList<Diagnostic> Diagnostics)> entities)
    {
        foreach (var (entity, diagnostics) in entities)
        {
            // Report diagnostics
            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }

            if (entity == null) continue;

            // Generate Fields class with field name constants
            var fieldsCode = FieldsGenerator.GenerateFieldsClass(entity);
            context.AddSource($"{entity.ClassName}Fields.g.cs", fieldsCode);

            // Generate Keys class with key builder methods
            var keysCode = KeysGenerator.GenerateKeysClass(entity);
            context.AddSource($"{entity.ClassName}Keys.g.cs", keysCode);

            // Generate placeholder implementation - will be expanded in later tasks
            var sourceCode = GenerateEntityImplementation(entity);
            context.AddSource($"{entity.ClassName}.g.cs", sourceCode);
        }
    }

    private static string GenerateEntityImplementation(EntityModel entity)
    {
        return $@"// <auto-generated />
#nullable enable

namespace {entity.Namespace}
{{
    // Entity analysis complete for {entity.ClassName}
    // Table: {entity.TableName}
    // Properties: {entity.Properties.Length}
    // Indexes: {entity.Indexes.Length}
    // Relationships: {entity.Relationships.Length}
    // Multi-item entity: {entity.IsMultiItemEntity}
    
    public partial class {entity.ClassName}
    {{
        // Full implementation will be added in subsequent tasks
        // Partition key: {entity.PartitionKeyProperty?.PropertyName ?? "None"}
        // Sort key: {entity.SortKeyProperty?.PropertyName ?? "None"}
    }}
}}";
    }
}