using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates static field name constant classes for DynamoDB entities.
/// </summary>
public static class FieldsGenerator
{
    /// <summary>
    /// Generates a static Fields class containing field name constants for the entity.
    /// </summary>
    /// <param name="entity">The entity model to generate fields for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateFieldsClass(EntityModel entity)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This code was generated by the DynamoDB Source Generator.");
        sb.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Field name constants for {entity.ClassName} DynamoDB attributes.");
        sb.AppendLine($"    /// These constants provide compile-time safety when referencing DynamoDB attribute names");
        sb.AppendLine($"    /// in queries, expressions, and other operations.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <remarks>");
        sb.AppendLine($"    /// Generated from entity: {entity.ClassName}");
        sb.AppendLine($"    /// Target table: {entity.TableName}");
        sb.AppendLine($"    /// Generated on: {DateTimeOffset.UtcNow:yyyy-MM-dd HH:mm:ss UTC}");
        sb.AppendLine($"    /// </remarks>");
        sb.AppendLine($"    public static partial class {entity.ClassName}Fields");
        sb.AppendLine("    {");
        
        // Generate main field constants
        GenerateMainFieldConstants(sb, entity);
        
        // Generate GSI field classes
        GenerateGsiFieldClasses(sb, entity);
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    /// <summary>
    /// Generates the main field constants for entity properties.
    /// </summary>
    private static void GenerateMainFieldConstants(StringBuilder sb, EntityModel entity)
    {
        var propertiesWithAttributes = entity.Properties
            .Where(p => p.HasAttributeMapping)
            .OrderBy(p => p.PropertyName)
            .ToArray();
            
        if (propertiesWithAttributes.Length == 0)
            return;
            
        foreach (var property in propertiesWithAttributes)
        {
            var fieldName = GetSafeFieldName(property.PropertyName);
            var attributeName = property.AttributeName;
            
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// DynamoDB attribute name for {property.PropertyName} property.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public const string {fieldName} = \"{attributeName}\";");
            sb.AppendLine();
        }
    }
    
    /// <summary>
    /// Generates nested GSI field classes for Global Secondary Index attributes.
    /// </summary>
    private static void GenerateGsiFieldClasses(StringBuilder sb, EntityModel entity)
    {
        if (entity.Indexes.Length == 0)
            return;
            
        foreach (var index in entity.Indexes.OrderBy(i => i.IndexName))
        {
            GenerateGsiFieldClass(sb, entity, index);
        }
    }
    
    /// <summary>
    /// Generates a nested field class for a specific GSI.
    /// </summary>
    private static void GenerateGsiFieldClass(StringBuilder sb, EntityModel entity, IndexModel index)
    {
        var className = GetSafeClassName($"{index.IndexName}Fields");
        
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Field name constants for {index.IndexName} Global Secondary Index.");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static partial class {className}");
        sb.AppendLine("        {");
        
        // Generate partition key field
        var partitionKeyProperty = entity.Properties.FirstOrDefault(p => p.PropertyName == index.PartitionKeyProperty);
        if (partitionKeyProperty != null)
        {
            var fieldName = GetSafeFieldName("PartitionKey");
            sb.AppendLine($"            /// <summary>");
            sb.AppendLine($"            /// Partition key attribute name for {index.IndexName} GSI.");
            sb.AppendLine($"            /// </summary>");
            sb.AppendLine($"            public const string {fieldName} = \"{partitionKeyProperty.AttributeName}\";");
            sb.AppendLine();
        }
        
        // Generate sort key field if exists
        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            var sortKeyProperty = entity.Properties.FirstOrDefault(p => p.PropertyName == index.SortKeyProperty);
            if (sortKeyProperty != null)
            {
                var fieldName = GetSafeFieldName("SortKey");
                sb.AppendLine($"            /// <summary>");
                sb.AppendLine($"            /// Sort key attribute name for {index.IndexName} GSI.");
                sb.AppendLine($"            /// </summary>");
                sb.AppendLine($"            public const string {fieldName} = \"{sortKeyProperty.AttributeName}\";");
                sb.AppendLine();
            }
        }
        
        // Generate projected field constants for properties that are part of this GSI
        GenerateGsiProjectedFields(sb, entity, index);
        
        sb.AppendLine("        }");
        sb.AppendLine();
    }
    
    /// <summary>
    /// Generates field constants for properties projected in a GSI.
    /// </summary>
    private static void GenerateGsiProjectedFields(StringBuilder sb, EntityModel entity, IndexModel index)
    {
        // Find all properties that have GSI attributes for this index (excluding key properties already handled)
        var projectedProperties = entity.Properties
            .Where(p => p.GlobalSecondaryIndexes.Any(gsi => gsi.IndexName == index.IndexName) &&
                       p.PropertyName != index.PartitionKeyProperty &&
                       p.PropertyName != index.SortKeyProperty &&
                       p.HasAttributeMapping)
            .OrderBy(p => p.PropertyName)
            .ToArray();
            
        foreach (var property in projectedProperties)
        {
            var fieldName = GetSafeFieldName(property.PropertyName);
            sb.AppendLine($"            /// <summary>");
            sb.AppendLine($"            /// DynamoDB attribute name for {property.PropertyName} property in {index.IndexName} GSI.");
            sb.AppendLine($"            /// </summary>");
            sb.AppendLine($"            public const string {fieldName} = \"{property.AttributeName}\";");
            sb.AppendLine();
        }
    }
    
    /// <summary>
    /// Converts a property name to a safe field name, handling reserved words and special cases.
    /// </summary>
    private static string GetSafeFieldName(string propertyName)
    {
        // Handle reserved C# keywords by prefixing with @
        var reservedWords = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
            "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
            "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
            "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
            "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
            "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
            "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
            "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
            "using", "virtual", "void", "volatile", "while"
        };
        
        // Only escape C# reserved words for field names
        // DynamoDB reserved words don't need to be escaped in C# field names
        if (reservedWords.Contains(propertyName))
        {
            return $"@{propertyName}";
        }
        
        // Ensure the field name starts with a letter or underscore
        if (!char.IsLetter(propertyName[0]) && propertyName[0] != '_')
        {
            return $"_{propertyName}";
        }
        
        return propertyName;
    }
    
    /// <summary>
    /// Converts an index name to a safe class name.
    /// </summary>
    private static string GetSafeClassName(string indexName)
    {
        // Remove invalid characters and ensure it starts with a letter or underscore
        var safeName = new StringBuilder();
        
        for (int i = 0; i < indexName.Length; i++)
        {
            char c = indexName[i];
            
            if (i == 0)
            {
                // First character must be letter or underscore
                if (char.IsLetter(c) || c == '_')
                {
                    safeName.Append(c);
                }
                else if (char.IsDigit(c))
                {
                    safeName.Append('_').Append(c);
                }
                else
                {
                    safeName.Append('_');
                }
            }
            else
            {
                // Subsequent characters can be letters, digits, or underscores
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    safeName.Append(c);
                }
                else
                {
                    safeName.Append('_');
                }
            }
        }
        
        var result = safeName.ToString();
        
        // Ensure we don't have an empty result
        if (string.IsNullOrEmpty(result))
        {
            result = "_Index";
        }
        
        return result;
    }
}