using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates entity mapping code for converting between C# objects and DynamoDB AttributeValue dictionaries.
/// </summary>
public static class MapperGenerator
{
    /// <summary>
    /// Generates the complete entity implementation with IDynamoDbEntity interface methods.
    /// </summary>
    /// <param name="entity">The entity model to generate mapping code for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateEntityImplementation(EntityModel entity)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This code was generated by the DynamoDB Source Generator.");
        sb.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using Amazon.DynamoDBv2.Model;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Attributes;");
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated implementation of IDynamoDbEntity for {entity.ClassName}.");
        sb.AppendLine($"    /// Provides automatic mapping between C# objects and DynamoDB AttributeValue dictionaries.");
        sb.AppendLine($"    /// Table: {entity.TableName}");
        if (entity.IsMultiItemEntity)
        {
            sb.AppendLine($"    /// Multi-item entity: Supports entities that span multiple DynamoDB items.");
        }
        if (entity.Relationships.Length > 0)
        {
            sb.AppendLine($"    /// Related entities: {entity.Relationships.Length} relationship(s) defined.");
        }
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    [SuppressMessage(\"Performance\", \"CA1822:Mark members as static\", Justification = \"Generated code implements interface\")]");
        sb.AppendLine($"    [SuppressMessage(\"Style\", \"IDE0060:Remove unused parameter\", Justification = \"Generated code follows interface contract\")]");
        sb.AppendLine($"    public partial class {entity.ClassName} : IDynamoDbEntity");
        sb.AppendLine("    {");
        
        GenerateToDynamoDbMethod(sb, entity);
        GenerateFromDynamoDbSingleMethod(sb, entity);
        GenerateFromDynamoDbMultiMethod(sb, entity);
        GenerateGetPartitionKeyMethod(sb, entity);
        GenerateMatchesEntityMethod(sb, entity);
        GenerateGetEntityMetadataMethod(sb, entity);
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        if (entity.IsMultiItemEntity)
        {
            GenerateMultiItemToDynamoDbMethod(sb, entity);
        }
        else
        {
            GenerateSingleItemToDynamoDbMethod(sb, entity);
        }
    }

    private static void GenerateSingleItemToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts an entity instance to a DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();
        sb.AppendLine("            var item = new Dictionary<string, AttributeValue>();");
        sb.AppendLine();

        // Generate property mappings for all properties (including collections as serialized data)
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyToAttributeValue(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
        
        // Generate ToDynamoDbMultiple method for single-item entities
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts a single-item entity to a list containing one DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static List<Dictionary<string, AttributeValue>> ToDynamoDbMultiple<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            return new List<Dictionary<string, AttributeValue>> { ToDynamoDb<TSelf>(entity) };");
        sb.AppendLine("        }");
    }

    private static void GenerateMultiItemToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts an entity instance to multiple DynamoDB AttributeValue dictionaries.");
        sb.AppendLine("        /// For multi-item entities, this creates one item per collection element plus the base entity.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            // For backward compatibility, return the first item from multi-item conversion");
        sb.AppendLine("            var items = ToDynamoDbMultiple<TSelf>(entity);");
        sb.AppendLine("            return items.FirstOrDefault() ?? new Dictionary<string, AttributeValue>();");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts a multi-item entity instance to multiple DynamoDB AttributeValue dictionaries.");
        sb.AppendLine("        /// Each collection item becomes a separate DynamoDB item with the same partition key.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static List<Dictionary<string, AttributeValue>> ToDynamoDbMultiple<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();
        sb.AppendLine("            var items = new List<Dictionary<string, AttributeValue>>();");
        sb.AppendLine();

        // Generate base partition key value
        var partitionKeyProperty = entity.PartitionKeyProperty;
        if (partitionKeyProperty != null)
        {
            sb.AppendLine("            // Generate base partition key");
            sb.AppendLine($"            var partitionKeyValue = {GetToAttributeValueExpression(partitionKeyProperty, $"typedEntity.{partitionKeyProperty.PropertyName}")};");
            sb.AppendLine();
        }

        // Generate items for each collection property
        var collectionProperties = entity.Properties.Where(p => p.IsCollection && p.HasAttributeMapping).ToArray();
        
        if (collectionProperties.Length > 0)
        {
            foreach (var collectionProperty in collectionProperties)
            {
                GenerateCollectionItemsMapping(sb, entity, collectionProperty, partitionKeyProperty);
            }
        }
        else
        {
            // If no collection properties, create a single item with non-collection properties
            sb.AppendLine("            // No collection properties found, create single item");
            sb.AppendLine("            var item = new Dictionary<string, AttributeValue>();");
            
            foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping && !p.IsCollection))
            {
                GeneratePropertyToAttributeValue(sb, property);
            }
            
            sb.AppendLine("            items.Add(item);");
        }

        sb.AppendLine();
        sb.AppendLine("            return items;");
        sb.AppendLine("        }");
    }

    private static void GenerateCollectionItemsMapping(StringBuilder sb, EntityModel entity, PropertyModel collectionProperty, PropertyModel? partitionKeyProperty)
    {
        var collectionElementType = GetCollectionElementType(collectionProperty.PropertyType);
        
        sb.AppendLine($"            // Process {collectionProperty.PropertyName} collection");
        sb.AppendLine($"            if (typedEntity.{collectionProperty.PropertyName} != null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                var {collectionProperty.PropertyName.ToLowerInvariant()}Index = 0;");
        sb.AppendLine($"                foreach (var {collectionProperty.PropertyName.ToLowerInvariant()}Item in typedEntity.{collectionProperty.PropertyName})");
        sb.AppendLine("                {");
        sb.AppendLine("                    var item = new Dictionary<string, AttributeValue>();");
        sb.AppendLine();
        
        // Add partition key to each item
        if (partitionKeyProperty != null)
        {
            sb.AppendLine("                    // Add partition key");
            sb.AppendLine($"                    item[\"{partitionKeyProperty.AttributeName}\"] = partitionKeyValue;");
            sb.AppendLine();
        }
        
        // Generate sort key for collection item (using index or item properties)
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty != null)
        {
            sb.AppendLine("                    // Generate sort key for collection item");
            if (IsComplexType(collectionElementType))
            {
                // For complex types, try to use a property from the collection item
                sb.AppendLine($"                    // TODO: Extract sort key from {collectionElementType} properties");
                sb.AppendLine($"                    item[\"{sortKeyProperty.AttributeName}\"] = new AttributeValue {{ S = $\"{collectionProperty.AttributeName}#{{++{collectionProperty.PropertyName.ToLowerInvariant()}Index:D3}}\" }};");
            }
            else
            {
                // For primitive types, use the value directly with index
                sb.AppendLine($"                    item[\"{sortKeyProperty.AttributeName}\"] = new AttributeValue {{ S = $\"{collectionProperty.AttributeName}#{{++{collectionProperty.PropertyName.ToLowerInvariant()}Index:D3}}\" }};");
            }
            sb.AppendLine();
        }
        
        // Add the collection item data
        if (IsComplexType(collectionElementType))
        {
            sb.AppendLine("                    // Add complex object properties");
            sb.AppendLine($"                    // TODO: Implement complex type mapping for {collectionElementType}");
            sb.AppendLine($"                    item[\"{collectionProperty.AttributeName}\"] = new AttributeValue {{ S = {collectionProperty.PropertyName.ToLowerInvariant()}Item?.ToString() ?? \"\" }};");
        }
        else
        {
            // For primitive collection items
            sb.AppendLine("                    // Add collection item value");
            sb.AppendLine($"                    item[\"{collectionProperty.AttributeName}\"] = {GetToAttributeValueExpression(new PropertyModel { PropertyType = collectionElementType, IsNullable = false }, $"{collectionProperty.PropertyName.ToLowerInvariant()}Item")};");
        }
        
        sb.AppendLine();
        sb.AppendLine("                    items.Add(item);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
    }

    private static void GeneratePropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        // Handle collection properties differently for single-item entities
        if (property.IsCollection)
        {
            GenerateCollectionPropertyToAttributeValue(sb, property);
            return;
        }
        
        // Handle nullable properties
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    private static void GenerateCollectionPropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        sb.AppendLine($"            // Serialize collection {propertyName} as JSON for single-item storage");
        sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                var {propertyName.ToLowerInvariant()}Json = System.Text.Json.JsonSerializer.Serialize(typedEntity.{propertyName});");
        sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ S = {propertyName.ToLowerInvariant()}Json }};");
        sb.AppendLine("            }");
    }

    private static string GetToAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        
        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "byte[]" or "System.Byte[]" => $"new AttributeValue {{ B = new MemoryStream({valueExpression}) }}",
            _ when IsEnumType(property.PropertyType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression}?.ToString() ?? \"\" }}"
        };
    }

    private static void GenerateFromDynamoDbSingleMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from a single DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(Dictionary<string, AttributeValue> item) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{typeof(TSelf).Name}}\");");
        sb.AppendLine();
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate property mappings from AttributeValue
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyFromAttributeValue(sb, property, entity);
        }

        // For single-item entities with relationships, related entities would be null
        // since we only have one item. This is expected behavior.
        if (entity.Relationships.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("            // Related entity properties remain null for single-item mapping");
            foreach (var relationship in entity.Relationships)
            {
                if (relationship.IsCollection)
                {
                    sb.AppendLine($"            entity.{relationship.PropertyName} = new {relationship.PropertyType}();");
                }
                // Single related entities remain null by default
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        if (property.IsCollection)
        {
            GenerateCollectionPropertyFromAttributeValue(sb, property, entity);
            return;
        }
        
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {GetFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateCollectionPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        sb.AppendLine($"            // Deserialize collection {propertyName} from JSON");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value) && !string.IsNullOrEmpty({propertyName.ToLowerInvariant()}Value.S))");
        sb.AppendLine("            {");
        sb.AppendLine($"                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = System.Text.Json.JsonSerializer.Deserialize<{property.PropertyType}>({propertyName.ToLowerInvariant()}Value.S);");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (System.Text.Json.JsonException ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({property.PropertyType}),");
        sb.AppendLine("                        ex)");
        sb.AppendLine($"                        .WithContext(\"JsonValue\", {propertyName.ToLowerInvariant()}Value.S)");
        sb.AppendLine($"                        .WithContext(\"DeserializationError\", \"Failed to deserialize JSON to collection type\");");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({property.PropertyType}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                // Initialize empty collection if no data found");
        sb.AppendLine($"                entity.{propertyName} = new {property.PropertyType}();");
        sb.AppendLine("            }");
    }

    private static string GetFromAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        var isNullable = property.IsNullable;
        
        var conversion = baseType switch
        {
            "string" => $"{valueExpression}.S",
            "int" or "System.Int32" => $"int.Parse({valueExpression}.N)",
            "long" or "System.Int64" => $"long.Parse({valueExpression}.N)",
            "double" or "System.Double" => $"double.Parse({valueExpression}.N)",
            "float" or "System.Single" => $"float.Parse({valueExpression}.N)",
            "decimal" or "System.Decimal" => $"decimal.Parse({valueExpression}.N)",
            "bool" or "System.Boolean" => $"{valueExpression}.BOOL",
            "DateTime" or "System.DateTime" => $"DateTime.Parse({valueExpression}.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => $"DateTimeOffset.Parse({valueExpression}.S)",
            "Guid" or "System.Guid" => $"Guid.Parse({valueExpression}.S)",
            "Ulid" => $"Ulid.Parse({valueExpression}.S)",
            "byte[]" or "System.Byte[]" => $"{valueExpression}.B.ToArray()",
            _ when IsEnumType(property.PropertyType) => $"Enum.Parse<{baseType}>({valueExpression}.S)",
            _ => $"{valueExpression}.S"
        };

        return conversion;
    }

    private static void GenerateFromDynamoDbMultiMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from multiple DynamoDB items.");
        sb.AppendLine("        /// For single-item entities, uses the first item. For multi-item entities, combines all items.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"items\">The collection of DynamoDB items to map from.</param>");
        sb.AppendLine("        /// <returns>A mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when items collection is null or empty.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(IList<Dictionary<string, AttributeValue>> items) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            if (items == null || items.Count == 0)");
        sb.AppendLine($"                throw new ArgumentException(\"Items collection cannot be null or empty\", nameof(items));");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        
        if (entity.IsMultiItemEntity)
        {
            GenerateMultiItemFromDynamoDb(sb, entity);
        }
        else
        {
            sb.AppendLine("                // Single-item entity: use the first item");
            sb.AppendLine("                return FromDynamoDb<TSelf>(items[0]);");
        }
        
        sb.AppendLine("            }");
        sb.AppendLine("            catch (DynamoDbMappingException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Re-throw mapping exceptions as-is");
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                throw DynamoDbMappingException.EntityConstructionFailed(");
        sb.AppendLine($"                    typeof({entity.ClassName}),");
        sb.AppendLine("                    items.FirstOrDefault() ?? new Dictionary<string, AttributeValue>(),");
        sb.AppendLine("                    ex)");
        sb.AppendLine("                    .WithContext(\"ItemCount\", items.Count)");
        sb.AppendLine("                    .WithContext(\"MappingType\", \"MultiItem\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void GenerateMultiItemFromDynamoDb(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Multi-item entity: combine all items into a single entity");
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();
        
        // First, populate non-collection properties from the first item (or any item that has them)
        var nonCollectionProperties = entity.Properties.Where(p => p.HasAttributeMapping && !p.IsCollection).ToArray();
        if (nonCollectionProperties.Length > 0)
        {
            sb.AppendLine("            // Populate non-collection properties from first available item");
            sb.AppendLine("            foreach (var item in items)");
            sb.AppendLine("            {");
            
            foreach (var property in nonCollectionProperties)
            {
                sb.AppendLine($"                if (item.TryGetValue(\"{property.AttributeName}\", out var {property.PropertyName.ToLowerInvariant()}Value))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    entity.{property.PropertyName} = {GetFromAttributeValueExpression(property, $"{property.PropertyName.ToLowerInvariant()}Value")};");
                sb.AppendLine("                }");
            }
            
            sb.AppendLine("                break; // Use first item for non-collection properties");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Then, populate collection properties by grouping items
        var collectionProperties = entity.Properties.Where(p => p.IsCollection && p.HasAttributeMapping).ToArray();
        foreach (var collectionProperty in collectionProperties)
        {
            GenerateCollectionPropertyFromItems(sb, entity, collectionProperty);
        }
        
        // Finally, populate related entity properties based on sort key patterns
        if (entity.Relationships.Length > 0)
        {
            GenerateRelatedEntityMapping(sb, entity);
        }
        
        sb.AppendLine("            return (TSelf)(object)entity;");
    }

    private static void GenerateCollectionPropertyFromItems(StringBuilder sb, EntityModel entity, PropertyModel collectionProperty)
    {
        var elementType = GetCollectionElementType(collectionProperty.PropertyType);
        
        sb.AppendLine($"            // Populate {collectionProperty.PropertyName} collection from items");
        sb.AppendLine($"            var {collectionProperty.PropertyName.ToLowerInvariant()}List = new List<{elementType}>();");
        sb.AppendLine();
        
        // Filter items that contain this collection's attribute
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{collectionProperty.AttributeName}\", out var {collectionProperty.PropertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("                {");
        
        if (IsComplexType(elementType))
        {
            // For complex types, we'd need to reconstruct the object
            sb.AppendLine($"                    // TODO: Implement complex type reconstruction for {elementType}");
            sb.AppendLine($"                    // For now, create default instance");
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = new {elementType}();");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }
        else
        {
            // For primitive types, convert directly
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = {GetFromAttributeValueExpression(new PropertyModel { PropertyType = elementType, IsNullable = false }, $"{collectionProperty.PropertyName.ToLowerInvariant()}Value")};");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine($"            entity.{collectionProperty.PropertyName} = {collectionProperty.PropertyName.ToLowerInvariant()}List;");
        sb.AppendLine();
    }

    private static void GenerateGetPartitionKeyMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Extracts the partition key value from a DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static string GetPartitionKey(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        var partitionKeyProperty = entity.PartitionKeyProperty;
        if (partitionKeyProperty != null)
        {
            sb.AppendLine($"            if (item.TryGetValue(\"{partitionKeyProperty.AttributeName}\", out var pkValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                return pkValue.S ?? string.Empty;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return string.Empty;");
        }
        else
        {
            sb.AppendLine("            // No partition key defined");
            sb.AppendLine("            return string.Empty;");
        }
        
        sb.AppendLine("        }");
    }

    private static void GenerateMatchesEntityMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Determines whether a DynamoDB item matches this entity type.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static bool MatchesEntity(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        // Check entity discriminator first if present
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"            // Check entity discriminator");
            sb.AppendLine($"            if (item.TryGetValue(\"EntityType\", out var entityTypeValue))");
            sb.AppendLine("            {");
            sb.AppendLine($"                return entityTypeValue.S == \"{entity.EntityDiscriminator}\";");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Use sort key pattern matching for entity type discrimination
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty != null && !string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine("            // Check sort key pattern for entity type discrimination");
            sb.AppendLine($"            if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                var sortKey = sortKeyValue.S ?? string.Empty;");
            
            // Generate pattern matching based on entity discriminator
            if (entity.EntityDiscriminator.Contains("*"))
            {
                // Wildcard pattern matching
                var pattern = entity.EntityDiscriminator.Replace("*", "");
                sb.AppendLine($"                return sortKey.StartsWith(\"{pattern}\");");
            }
            else
            {
                // Exact pattern matching
                sb.AppendLine($"                return sortKey == \"{entity.EntityDiscriminator}\" || sortKey.StartsWith(\"{entity.EntityDiscriminator}#\");");
            }
            
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Check if required attributes exist
        var requiredAttributes = entity.Properties
            .Where(p => p.HasAttributeMapping && (p.IsPartitionKey || !p.IsNullable))
            .ToArray();
        
        if (requiredAttributes.Length > 0)
        {
            sb.AppendLine("            // Check if required attributes exist");
            foreach (var property in requiredAttributes)
            {
                sb.AppendLine($"            if (!item.ContainsKey(\"{property.AttributeName}\"))");
                sb.AppendLine("                return false;");
            }
            sb.AppendLine();
        }
        
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
    }

    private static void GenerateGetEntityMetadataMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets metadata about the entity structure for future LINQ support.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static EntityMetadata GetEntityMetadata()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new EntityMetadata");
        sb.AppendLine("            {");
        sb.AppendLine($"                TableName = \"{entity.TableName}\",");
        
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"                EntityDiscriminator = \"{entity.EntityDiscriminator}\",");
        }
        
        sb.AppendLine($"                IsMultiItemEntity = {entity.IsMultiItemEntity.ToString().ToLowerInvariant()},");
        sb.AppendLine("                Properties = new PropertyMetadata[]");
        sb.AppendLine("                {");
        
        // Generate property metadata
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyMetadata(sb, property);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Indexes = new IndexMetadata[]");
        sb.AppendLine("                {");
        
        // Generate index metadata
        foreach (var index in entity.Indexes)
        {
            GenerateIndexMetadata(sb, index);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Relationships = new RelationshipMetadata[]");
        sb.AppendLine("                {");
        
        // Generate relationship metadata
        foreach (var relationship in entity.Relationships)
        {
            GenerateRelationshipMetadata(sb, relationship);
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyMetadata(StringBuilder sb, PropertyModel property)
    {
        sb.AppendLine("                    new PropertyMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{property.PropertyName}\",");
        sb.AppendLine($"                        AttributeName = \"{property.AttributeName}\",");
        sb.AppendLine($"                        PropertyType = typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        IsPartitionKey = {property.IsPartitionKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsSortKey = {property.IsSortKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsCollection = {property.IsCollection.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsNullable = {property.IsNullable.ToString().ToLowerInvariant()},");
        
        // Add supported operations if available
        if (property.Queryable?.HasSupportedOperations == true)
        {
            var operations = string.Join(", ", property.Queryable.SupportedOperations.Select(op => $"DynamoDbOperation.{op}"));
            sb.AppendLine($"                        SupportedOperations = new[] {{ {operations} }},");
        }
        else
        {
            sb.AppendLine("                        SupportedOperations = Array.Empty<DynamoDbOperation>(),");
        }
        
        // Add available indexes if specified
        if (property.Queryable?.HasIndexRestrictions == true)
        {
            var indexes = string.Join(", ", property.Queryable.AvailableInIndexes.Select(idx => $"\"{idx}\""));
            sb.AppendLine($"                        AvailableInIndexes = new[] {{ {indexes} }},");
        }
        
        // Add key format if available
        if (property.KeyFormat != null)
        {
            sb.AppendLine("                        KeyFormat = new KeyFormatMetadata");
            sb.AppendLine("                        {");
            if (!string.IsNullOrEmpty(property.KeyFormat.Prefix))
            {
                sb.AppendLine($"                            Prefix = \"{property.KeyFormat.Prefix}\",");
            }
            if (property.KeyFormat.Separator != "#")
            {
                sb.AppendLine($"                            Separator = \"{property.KeyFormat.Separator}\"");
            }
            sb.AppendLine("                        }");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateIndexMetadata(StringBuilder sb, IndexModel index)
    {
        sb.AppendLine("                    new IndexMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        IndexName = \"{index.IndexName}\",");
        sb.AppendLine($"                        PartitionKeyProperty = \"{index.PartitionKeyProperty}\",");
        
        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            sb.AppendLine($"                        SortKeyProperty = \"{index.SortKeyProperty}\",");
        }
        
        if (index.ProjectedProperties.Length > 0)
        {
            var projectedProps = string.Join(", ", index.ProjectedProperties.Select(p => $"\"{p}\""));
            sb.AppendLine($"                        ProjectedProperties = new[] {{ {projectedProps} }},");
        }
        else
        {
            sb.AppendLine("                        ProjectedProperties = Array.Empty<string>(),");
        }
        
        if (!string.IsNullOrEmpty(index.PartitionKeyFormat))
        {
            sb.AppendLine($"                        KeyFormat = \"{index.PartitionKeyFormat}\"");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateRelationshipMetadata(StringBuilder sb, RelationshipModel relationship)
    {
        sb.AppendLine("                    new RelationshipMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{relationship.PropertyName}\",");
        sb.AppendLine($"                        SortKeyPattern = \"{relationship.SortKeyPattern}\",");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            sb.AppendLine($"                        EntityType = typeof({relationship.EntityType}),");
        }
        
        sb.AppendLine($"                        IsCollection = {relationship.IsCollection.ToString().ToLowerInvariant()}");
        sb.AppendLine("                    },");
    }

    private static string GetBaseType(string typeName)
    {
        // Remove nullable annotations and generic type parameters
        var baseType = typeName.TrimEnd('?');
        
        // Handle nullable value types like int?, bool?, etc.
        if (baseType.StartsWith("System.Nullable<") && baseType.EndsWith(">"))
        {
            var innerType = baseType.Substring(16, baseType.Length - 17); // Remove "System.Nullable<" and ">"
            return innerType;
        }
        
        return baseType;
    }

    private static string GetTypeForMetadata(string typeName)
    {
        // For metadata, we need the actual type without nullable annotations
        var baseType = GetBaseType(typeName);
        
        // Convert common type aliases to full type names for typeof()
        return baseType switch
        {
            "string" => "string",
            "int" => "int",
            "long" => "long", 
            "double" => "double",
            "float" => "float",
            "decimal" => "decimal",
            "bool" => "bool",
            "byte[]" => "byte[]",
            _ => baseType
        };
    }

    private static bool IsEnumType(string typeName)
    {
        // This is a simplified check - in a real implementation, we'd use semantic analysis
        // For now, assume any type not in our known primitives might be an enum
        var baseType = GetBaseType(typeName);
        var knownPrimitives = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double", 
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid"
        };
        
        return !knownPrimitives.Contains(baseType) && 
               !baseType.StartsWith("System.Collections.Generic.") &&
               !baseType.StartsWith("List<") &&
               !baseType.StartsWith("IList<") &&
               !baseType.StartsWith("ICollection<") &&
               !baseType.StartsWith("IEnumerable<");
    }

    private static string GetCollectionElementType(string collectionType)
    {
        // Extract element type from collection types
        if (collectionType.StartsWith("List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(5, collectionType.Length - 6);
        }
        if (collectionType.StartsWith("IList<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(6, collectionType.Length - 7);
        }
        if (collectionType.StartsWith("ICollection<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("IEnumerable<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("System.Collections.Generic.List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(33, collectionType.Length - 34);
        }
        
        // Default to object if we can't determine the element type
        return "object";
    }

    private static bool IsComplexType(string typeName)
    {
        var baseType = GetBaseType(typeName);
        var primitiveTypes = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double", 
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid", "object"
        };
        
        return !primitiveTypes.Contains(baseType);
    }

    private static void GenerateRelatedEntityMapping(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Populate related entity properties based on sort key patterns");
        
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty == null)
        {
            sb.AppendLine("            // No sort key defined - cannot map related entities");
            return;
        }
        
        foreach (var relationship in entity.Relationships)
        {
            sb.AppendLine();
            sb.AppendLine($"            // Map related entity: {relationship.PropertyName}");
            
            if (relationship.IsCollection)
            {
                GenerateRelatedEntityCollectionMapping(sb, entity, relationship, sortKeyProperty);
            }
            else
            {
                GenerateRelatedEntitySingleMapping(sb, entity, relationship, sortKeyProperty);
            }
        }
    }

    private static void GenerateRelatedEntityCollectionMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var elementType = GetCollectionElementType(relationship.PropertyType);
        
        sb.AppendLine($"            var {relationship.PropertyName.ToLowerInvariant()}Items = new List<{elementType}>();");
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S ?? string.Empty;");
        
        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);
        
        sb.AppendLine("                    {");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            var relatedEntity = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine($"                            {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of element type
            sb.AppendLine($"                        // Generic mapping to {elementType}");
            sb.AppendLine($"                        var relatedEntity = new {elementType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {elementType}");
            sb.AppendLine($"                        {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
        }
        
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine($"            entity.{relationship.PropertyName} = {relationship.PropertyName.ToLowerInvariant()}Items;");
    }

    private static void GenerateRelatedEntitySingleMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var propertyType = relationship.EntityType ?? GetBaseType(relationship.PropertyType);
        
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S ?? string.Empty;");
        
        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);
        
        sb.AppendLine("                    {");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            entity.{relationship.PropertyName} = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine("                            break; // Found the related entity");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of property type
            sb.AppendLine($"                        // Generic mapping to {propertyType}");
            sb.AppendLine($"                        entity.{relationship.PropertyName} = new {propertyType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {propertyType}");
            sb.AppendLine("                        break; // Found the related entity");
        }
        
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateSortKeyPatternMatching(StringBuilder sb, string sortKeyPattern)
    {
        if (sortKeyPattern.Contains("*"))
        {
            // Wildcard pattern matching
            var prefix = sortKeyPattern.Replace("*", "");
            sb.AppendLine($"                    if (sortKey.StartsWith(\"{prefix}\"))");
        }
        else
        {
            // Exact pattern matching
            sb.AppendLine($"                    if (sortKey == \"{sortKeyPattern}\" || sortKey.StartsWith(\"{sortKeyPattern}#\"))");
        }
    }
}