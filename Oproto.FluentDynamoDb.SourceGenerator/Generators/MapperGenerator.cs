using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates entity mapping code for converting between C# objects and DynamoDB AttributeValue dictionaries.
/// </summary>
public static class MapperGenerator
{
    /// <summary>
    /// Generates the complete entity implementation with IDynamoDbEntity interface methods.
    /// </summary>
    /// <param name="entity">The entity model to generate mapping code for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateEntityImplementation(EntityModel entity)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This code was generated by the DynamoDB Source Generator.");
        sb.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using Amazon.DynamoDBv2.Model;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Attributes;");
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated implementation of IDynamoDbEntity for {entity.ClassName}.");
        sb.AppendLine($"    /// Provides automatic mapping between C# objects and DynamoDB AttributeValue dictionaries.");
        sb.AppendLine($"    /// Table: {entity.TableName}");
        if (entity.Relationships.Length > 0)
        {
            sb.AppendLine($"    /// Related entities: {entity.Relationships.Length} relationship(s) defined.");
        }
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    [SuppressMessage(\"Performance\", \"CA1822:Mark members as static\", Justification = \"Generated code implements interface\")]");
        sb.AppendLine($"    [SuppressMessage(\"Style\", \"IDE0060:Remove unused parameter\", Justification = \"Generated code follows interface contract\")]");
        sb.AppendLine($"    public partial class {entity.ClassName} : IDynamoDbEntity");
        sb.AppendLine("    {");
        
        GenerateToDynamoDbMethod(sb, entity);
        GenerateFromDynamoDbSingleMethod(sb, entity);
        GenerateFromDynamoDbMultiMethod(sb, entity);
        GenerateGetPartitionKeyMethod(sb, entity);
        GenerateMatchesEntityMethod(sb, entity);
        GenerateGetEntityMetadataMethod(sb, entity);
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        // Use optimized code generation for better performance
        Performance.OptimizedCodeGenerator.GenerateOptimizedToDynamoDbMethod(sb, entity);
    }

    private static void GenerateSingleItemToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts an entity instance to a DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();

        // Generate computed key logic before mapping
        var computedProperties = entity.Properties.Where(p => p.IsComputed).ToArray();
        if (computedProperties.Length > 0)
        {
            sb.AppendLine("            // Compute composite keys before mapping");
            foreach (var computedProperty in computedProperties)
            {
                GenerateComputedKeyLogic(sb, computedProperty);
            }
            sb.AppendLine();
        }

        sb.AppendLine("            var item = new Dictionary<string, AttributeValue>();");
        sb.AppendLine();

        // Generate property mappings for all properties (including collections as serialized data)
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyToAttributeValue(sb, property);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
        
        // Generate ToDynamoDbMultiple method for single-item entities
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts a single-item entity to a list containing one DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static List<Dictionary<string, AttributeValue>> ToDynamoDbMultiple<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            return new List<Dictionary<string, AttributeValue>> { ToDynamoDb<TSelf>(entity) };");
        sb.AppendLine("        }");
    }





    private static void GeneratePropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        // Handle collection properties differently for single-item entities
        if (property.IsCollection)
        {
            GenerateCollectionPropertyToAttributeValue(sb, property);
            return;
        }
        
        // Handle nullable properties
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    private static void GenerateCollectionPropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var collectionElementType = GetCollectionElementType(property.PropertyType);
        
        sb.AppendLine($"            // Convert collection {propertyName} to native DynamoDB type");
        sb.AppendLine($"            if (typedEntity.{propertyName} != null && typedEntity.{propertyName}.Count > 0)");
        sb.AppendLine("            {");
        
        // Determine the appropriate DynamoDB collection type based on element type
        var baseElementType = GetBaseType(collectionElementType);
        
        if (baseElementType == "string")
        {
            // Use String Set (SS) for string collections
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    SS = typedEntity.{propertyName}.ToList()");
            sb.AppendLine("                };");
        }
        else if (IsNumericType(baseElementType))
        {
            // Use Number Set (NS) for numeric collections
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    NS = typedEntity.{propertyName}.Select(x => x.ToString()).ToList()");
            sb.AppendLine("                };");
        }
        else
        {
            // Use List (L) for complex types or mixed collections
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    L = typedEntity.{propertyName}.Select(x => {GetToAttributeValueExpressionForCollectionElement(collectionElementType, "x")}).ToList()");
            sb.AppendLine("                };");
        }
        
        sb.AppendLine("            }");
    }

    private static string GetToAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        
        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "byte[]" or "System.Byte[]" => $"new AttributeValue {{ B = new MemoryStream({valueExpression}) }}",
            _ when IsEnumType(property.PropertyType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression}?.ToString() ?? \"\" }}"
        };
    }

    private static void GenerateFromDynamoDbSingleMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from a single DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(Dictionary<string, AttributeValue> item) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{typeof(TSelf).Name}}\");");
        sb.AppendLine();
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate property mappings from AttributeValue
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyFromAttributeValue(sb, property, entity);
        }

        // Generate extracted key logic after mapping from DynamoDB
        var extractedProperties = entity.Properties.Where(p => p.IsExtracted).ToArray();
        if (extractedProperties.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("            // Extract component properties from composite keys");
            foreach (var extractedProperty in extractedProperties)
            {
                GenerateExtractedKeyLogic(sb, extractedProperty);
            }
        }

        // For single-item entities with relationships, related entities would be null
        // since we only have one item. This is expected behavior.
        if (entity.Relationships.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("            // Related entity properties remain null for single-item mapping");
            foreach (var relationship in entity.Relationships)
            {
                if (relationship.IsCollection)
                {
                    sb.AppendLine($"            entity.{relationship.PropertyName} = new {relationship.PropertyType}();");
                }
                // Single related entities remain null by default
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        
        if (property.IsCollection)
        {
            GenerateCollectionPropertyFromAttributeValue(sb, property, entity);
            return;
        }
        
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {GetFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateCollectionPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var collectionElementType = GetCollectionElementType(property.PropertyType);
        var baseElementType = GetBaseType(collectionElementType);
        
        sb.AppendLine($"            // Convert collection {propertyName} from native DynamoDB type");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine($"                try");
        sb.AppendLine("                {");
        
        if (baseElementType == "string")
        {
            // Handle String Set (SS)
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.SS != null && {propertyName.ToLowerInvariant()}Value.SS.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.SS);");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        else if (IsNumericType(baseElementType))
        {
            // Handle Number Set (NS)
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.NS != null && {propertyName.ToLowerInvariant()}Value.NS.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.NS.Select({GetNumericConversionExpression(baseElementType)}));");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        else
        {
            // Handle List (L) for complex types
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.L != null && {propertyName.ToLowerInvariant()}Value.L.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.L.Select({GetFromAttributeValueExpressionForCollectionElement(collectionElementType)}));");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({property.PropertyType}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                // Initialize empty collection if no data found");
        sb.AppendLine($"                entity.{propertyName} = new {property.PropertyType}();");
        sb.AppendLine("            }");
    }

    private static string GetFromAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        var isNullable = property.IsNullable;
        
        var conversion = baseType switch
        {
            "string" => $"{valueExpression}.S",
            "int" or "System.Int32" => $"int.Parse({valueExpression}.N)",
            "long" or "System.Int64" => $"long.Parse({valueExpression}.N)",
            "double" or "System.Double" => $"double.Parse({valueExpression}.N)",
            "float" or "System.Single" => $"float.Parse({valueExpression}.N)",
            "decimal" or "System.Decimal" => $"decimal.Parse({valueExpression}.N)",
            "bool" or "System.Boolean" => $"{valueExpression}.BOOL",
            "DateTime" or "System.DateTime" => $"DateTime.Parse({valueExpression}.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => $"DateTimeOffset.Parse({valueExpression}.S)",
            "Guid" or "System.Guid" => $"Guid.Parse({valueExpression}.S)",
            "Ulid" => $"Ulid.Parse({valueExpression}.S)",
            "byte[]" or "System.Byte[]" => $"{valueExpression}.B.ToArray()",
            _ when IsEnumType(property.PropertyType) => $"Enum.Parse<{baseType}>({valueExpression}.S)",
            _ => $"{valueExpression}.S"
        };

        return conversion;
    }

    private static void GenerateFromDynamoDbMultiMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from multiple DynamoDB items.");
        sb.AppendLine("        /// For single-item entities, uses the first item. For multi-item entities, combines all items.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"items\">The collection of DynamoDB items to map from.</param>");
        sb.AppendLine("        /// <returns>A mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when items collection is null or empty.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(IList<Dictionary<string, AttributeValue>> items) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            if (items == null || items.Count == 0)");
        sb.AppendLine($"                throw new ArgumentException(\"Items collection cannot be null or empty\", nameof(items));");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        
        if (entity.IsMultiItemEntity)
        {
            GenerateMultiItemFromDynamoDb(sb, entity);
        }
        else
        {
            sb.AppendLine("                // Single-item entity: use the first item");
            sb.AppendLine("                return FromDynamoDb<TSelf>(items[0]);");
        }
        
        sb.AppendLine("            }");
        sb.AppendLine("            catch (DynamoDbMappingException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Re-throw mapping exceptions as-is");
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                throw DynamoDbMappingException.EntityConstructionFailed(");
        sb.AppendLine($"                    typeof({entity.ClassName}),");
        sb.AppendLine("                    items.FirstOrDefault() ?? new Dictionary<string, AttributeValue>(),");
        sb.AppendLine("                    ex)");
        sb.AppendLine("                    .WithContext(\"ItemCount\", items.Count)");
        sb.AppendLine("                    .WithContext(\"MappingType\", \"MultiItem\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void GenerateMultiItemFromDynamoDb(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Multi-item entity: combine all items into a single entity");
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();
        
        // First, populate non-collection properties from the first item (or any item that has them)
        var nonCollectionProperties = entity.Properties.Where(p => p.HasAttributeMapping && !p.IsCollection).ToArray();
        if (nonCollectionProperties.Length > 0)
        {
            sb.AppendLine("            // Populate non-collection properties from first available item");
            sb.AppendLine("            foreach (var item in items)");
            sb.AppendLine("            {");
            
            foreach (var property in nonCollectionProperties)
            {
                sb.AppendLine($"                if (item.TryGetValue(\"{property.AttributeName}\", out var {property.PropertyName.ToLowerInvariant()}Value))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    entity.{property.PropertyName} = {GetFromAttributeValueExpression(property, $"{property.PropertyName.ToLowerInvariant()}Value")};");
                sb.AppendLine("                }");
            }
            
            sb.AppendLine("                break; // Use first item for non-collection properties");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Then, populate collection properties by grouping items
        var collectionProperties = entity.Properties.Where(p => p.IsCollection && p.HasAttributeMapping).ToArray();
        foreach (var collectionProperty in collectionProperties)
        {
            GenerateCollectionPropertyFromItems(sb, entity, collectionProperty);
        }
        
        // Finally, populate related entity properties based on sort key patterns
        if (entity.Relationships.Length > 0)
        {
            GenerateRelatedEntityMapping(sb, entity);
        }
        
        sb.AppendLine("            return (TSelf)(object)entity;");
    }

    private static void GenerateCollectionPropertyFromItems(StringBuilder sb, EntityModel entity, PropertyModel collectionProperty)
    {
        var elementType = GetCollectionElementType(collectionProperty.PropertyType);
        
        sb.AppendLine($"            // Populate {collectionProperty.PropertyName} collection from items");
        sb.AppendLine($"            var {collectionProperty.PropertyName.ToLowerInvariant()}List = new List<{elementType}>();");
        sb.AppendLine();
        
        // Filter items that contain this collection's attribute
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{collectionProperty.AttributeName}\", out var {collectionProperty.PropertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("                {");
        
        if (IsComplexType(elementType))
        {
            // For complex types, we'd need to reconstruct the object
            sb.AppendLine($"                    // TODO: Implement complex type reconstruction for {elementType}");
            sb.AppendLine($"                    // For now, create default instance");
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = new {elementType}();");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }
        else
        {
            // For primitive types, convert directly
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = {GetFromAttributeValueExpression(new PropertyModel { PropertyType = elementType, IsNullable = false }, $"{collectionProperty.PropertyName.ToLowerInvariant()}Value")};");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine($"            entity.{collectionProperty.PropertyName} = {collectionProperty.PropertyName.ToLowerInvariant()}List;");
        sb.AppendLine();
    }

    private static void GenerateGetPartitionKeyMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Extracts the partition key value from a DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static string GetPartitionKey(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        var partitionKeyProperty = entity.PartitionKeyProperty;
        if (partitionKeyProperty != null)
        {
            sb.AppendLine($"            if (item.TryGetValue(\"{partitionKeyProperty.AttributeName}\", out var pkValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                return pkValue.S ?? string.Empty;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return string.Empty;");
        }
        else
        {
            sb.AppendLine("            // No partition key defined");
            sb.AppendLine("            return string.Empty;");
        }
        
        sb.AppendLine("        }");
    }

    private static void GenerateMatchesEntityMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Determines whether a DynamoDB item matches this entity type.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static bool MatchesEntity(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");
        
        // Check entity discriminator first if present
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"            // Check entity discriminator");
            sb.AppendLine($"            if (item.TryGetValue(\"EntityType\", out var entityTypeValue))");
            sb.AppendLine("            {");
            sb.AppendLine($"                return entityTypeValue.S == \"{entity.EntityDiscriminator}\";");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Use sort key pattern matching for entity type discrimination
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty != null && !string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine("            // Check sort key pattern for entity type discrimination");
            sb.AppendLine($"            if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                var sortKey = sortKeyValue.S ?? string.Empty;");
            
            // Generate pattern matching based on entity discriminator
            if (entity.EntityDiscriminator.Contains("*"))
            {
                // Wildcard pattern matching
                var pattern = entity.EntityDiscriminator.Replace("*", "");
                sb.AppendLine($"                return sortKey.StartsWith(\"{pattern}\");");
            }
            else
            {
                // Exact pattern matching
                sb.AppendLine($"                return sortKey == \"{entity.EntityDiscriminator}\" || sortKey.StartsWith(\"{entity.EntityDiscriminator}#\");");
            }
            
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // Check if required attributes exist
        var requiredAttributes = entity.Properties
            .Where(p => p.HasAttributeMapping && (p.IsPartitionKey || !p.IsNullable))
            .ToArray();
        
        if (requiredAttributes.Length > 0)
        {
            sb.AppendLine("            // Check if required attributes exist");
            foreach (var property in requiredAttributes)
            {
                sb.AppendLine($"            if (!item.ContainsKey(\"{property.AttributeName}\"))");
                sb.AppendLine("                return false;");
            }
            sb.AppendLine();
        }
        
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
    }

    private static void GenerateGetEntityMetadataMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets metadata about the entity structure for future LINQ support.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static EntityMetadata GetEntityMetadata()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new EntityMetadata");
        sb.AppendLine("            {");
        sb.AppendLine($"                TableName = \"{entity.TableName}\",");
        
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"                EntityDiscriminator = \"{entity.EntityDiscriminator}\",");
        }
        
        sb.AppendLine($"                IsMultiItemEntity = false,");
        sb.AppendLine("                Properties = new PropertyMetadata[]");
        sb.AppendLine("                {");
        
        // Generate property metadata
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyMetadata(sb, property);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Indexes = new IndexMetadata[]");
        sb.AppendLine("                {");
        
        // Generate index metadata
        foreach (var index in entity.Indexes)
        {
            GenerateIndexMetadata(sb, index);
        }
        
        sb.AppendLine("                },");
        sb.AppendLine("                Relationships = new RelationshipMetadata[]");
        sb.AppendLine("                {");
        
        // Generate relationship metadata
        foreach (var relationship in entity.Relationships)
        {
            GenerateRelationshipMetadata(sb, relationship);
        }
        
        sb.AppendLine("                }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyMetadata(StringBuilder sb, PropertyModel property)
    {
        sb.AppendLine("                    new PropertyMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{property.PropertyName}\",");
        sb.AppendLine($"                        AttributeName = \"{property.AttributeName}\",");
        sb.AppendLine($"                        PropertyType = typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        IsPartitionKey = {property.IsPartitionKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsSortKey = {property.IsSortKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsCollection = {property.IsCollection.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsNullable = {property.IsNullable.ToString().ToLowerInvariant()},");
        
        // Add supported operations if available
        if (property.Queryable?.HasSupportedOperations == true)
        {
            var operations = string.Join(", ", property.Queryable.SupportedOperations.Select(op => $"DynamoDbOperation.{op}"));
            sb.AppendLine($"                        SupportedOperations = new[] {{ {operations} }},");
        }
        else
        {
            sb.AppendLine("                        SupportedOperations = Array.Empty<DynamoDbOperation>(),");
        }
        
        // Add available indexes if specified
        if (property.Queryable?.HasIndexRestrictions == true)
        {
            var indexes = string.Join(", ", property.Queryable.AvailableInIndexes.Select(idx => $"\"{idx}\""));
            sb.AppendLine($"                        AvailableInIndexes = new[] {{ {indexes} }},");
        }
        
        // Add key format if available
        if (property.KeyFormat != null)
        {
            sb.AppendLine("                        KeyFormat = new KeyFormatMetadata");
            sb.AppendLine("                        {");
            if (!string.IsNullOrEmpty(property.KeyFormat.Prefix))
            {
                sb.AppendLine($"                            Prefix = \"{property.KeyFormat.Prefix}\",");
            }
            if (property.KeyFormat.Separator != "#")
            {
                sb.AppendLine($"                            Separator = \"{property.KeyFormat.Separator}\"");
            }
            sb.AppendLine("                        }");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateIndexMetadata(StringBuilder sb, IndexModel index)
    {
        sb.AppendLine("                    new IndexMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        IndexName = \"{index.IndexName}\",");
        sb.AppendLine($"                        PartitionKeyProperty = \"{index.PartitionKeyProperty}\",");
        
        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            sb.AppendLine($"                        SortKeyProperty = \"{index.SortKeyProperty}\",");
        }
        
        if (index.ProjectedProperties.Length > 0)
        {
            var projectedProps = string.Join(", ", index.ProjectedProperties.Select(p => $"\"{p}\""));
            sb.AppendLine($"                        ProjectedProperties = new[] {{ {projectedProps} }},");
        }
        else
        {
            sb.AppendLine("                        ProjectedProperties = Array.Empty<string>(),");
        }
        
        if (!string.IsNullOrEmpty(index.PartitionKeyFormat))
        {
            sb.AppendLine($"                        KeyFormat = \"{index.PartitionKeyFormat}\"");
        }
        
        sb.AppendLine("                    },");
    }

    private static void GenerateRelationshipMetadata(StringBuilder sb, RelationshipModel relationship)
    {
        sb.AppendLine("                    new RelationshipMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{relationship.PropertyName}\",");
        sb.AppendLine($"                        SortKeyPattern = \"{relationship.SortKeyPattern}\",");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            sb.AppendLine($"                        EntityType = typeof({relationship.EntityType}),");
        }
        
        sb.AppendLine($"                        IsCollection = {relationship.IsCollection.ToString().ToLowerInvariant()}");
        sb.AppendLine("                    },");
    }

    private static string GetBaseType(string typeName)
    {
        // Remove nullable annotations and generic type parameters
        var baseType = typeName.TrimEnd('?');
        
        // Handle nullable value types like int?, bool?, etc.
        if (baseType.StartsWith("System.Nullable<") && baseType.EndsWith(">"))
        {
            var innerType = baseType.Substring(16, baseType.Length - 17); // Remove "System.Nullable<" and ">"
            return innerType;
        }
        
        return baseType;
    }

    private static string GetTypeForMetadata(string typeName)
    {
        // For metadata, we need the actual type without nullable annotations
        var baseType = GetBaseType(typeName);
        
        // Convert common type aliases to full type names for typeof()
        return baseType switch
        {
            "string" => "string",
            "int" => "int",
            "long" => "long", 
            "double" => "double",
            "float" => "float",
            "decimal" => "decimal",
            "bool" => "bool",
            "byte[]" => "byte[]",
            _ => baseType
        };
    }

    private static bool IsEnumType(string typeName)
    {
        // This is a simplified check - in a real implementation, we'd use semantic analysis
        // For now, assume any type not in our known primitives might be an enum
        var baseType = GetBaseType(typeName);
        var knownPrimitives = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double", 
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid"
        };
        
        return !knownPrimitives.Contains(baseType) && 
               !baseType.StartsWith("System.Collections.Generic.") &&
               !baseType.StartsWith("List<") &&
               !baseType.StartsWith("IList<") &&
               !baseType.StartsWith("ICollection<") &&
               !baseType.StartsWith("IEnumerable<");
    }

    private static string GetCollectionElementType(string collectionType)
    {
        // Extract element type from collection types
        if (collectionType.StartsWith("List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(5, collectionType.Length - 6);
        }
        if (collectionType.StartsWith("IList<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(6, collectionType.Length - 7);
        }
        if (collectionType.StartsWith("ICollection<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("IEnumerable<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("System.Collections.Generic.List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(33, collectionType.Length - 34);
        }
        
        // Default to object if we can't determine the element type
        return "object";
    }

    private static bool IsComplexType(string typeName)
    {
        var baseType = GetBaseType(typeName);
        var primitiveTypes = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double", 
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid", "object"
        };
        
        return !primitiveTypes.Contains(baseType);
    }

    private static bool IsNumericType(string typeName)
    {
        var baseType = GetBaseType(typeName);
        var numericTypes = new[]
        {
            "int", "long", "double", "float", "decimal", "byte", "short", "uint", "ulong", "ushort",
            "System.Int32", "System.Int64", "System.Double", "System.Single", "System.Decimal", 
            "System.Byte", "System.Int16", "System.UInt32", "System.UInt64", "System.UInt16"
        };
        
        return numericTypes.Contains(baseType);
    }

    private static string GetToAttributeValueExpressionForCollectionElement(string elementType, string valueExpression)
    {
        var baseType = GetBaseType(elementType);
        
        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ when IsEnumType(elementType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression}?.ToString() ?? \"\" }}"
        };
    }

    private static string GetNumericConversionExpression(string numericType)
    {
        return numericType switch
        {
            "int" or "System.Int32" => "x => int.Parse(x)",
            "long" or "System.Int64" => "x => long.Parse(x)",
            "double" or "System.Double" => "x => double.Parse(x)",
            "float" or "System.Single" => "x => float.Parse(x)",
            "decimal" or "System.Decimal" => "x => decimal.Parse(x)",
            "byte" or "System.Byte" => "x => byte.Parse(x)",
            "short" or "System.Int16" => "x => short.Parse(x)",
            "uint" or "System.UInt32" => "x => uint.Parse(x)",
            "ulong" or "System.UInt64" => "x => ulong.Parse(x)",
            "ushort" or "System.UInt16" => "x => ushort.Parse(x)",
            _ => "x => x" // fallback to string
        };
    }

    private static string GetFromAttributeValueExpressionForCollectionElement(string elementType)
    {
        var baseType = GetBaseType(elementType);
        
        return baseType switch
        {
            "string" => "x => x.S",
            "int" or "System.Int32" => "x => int.Parse(x.N)",
            "long" or "System.Int64" => "x => long.Parse(x.N)",
            "double" or "System.Double" => "x => double.Parse(x.N)",
            "float" or "System.Single" => "x => float.Parse(x.N)",
            "decimal" or "System.Decimal" => "x => decimal.Parse(x.N)",
            "bool" or "System.Boolean" => "x => x.BOOL",
            "DateTime" or "System.DateTime" => "x => DateTime.Parse(x.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => "x => DateTimeOffset.Parse(x.S)",
            "Guid" or "System.Guid" => "x => Guid.Parse(x.S)",
            "Ulid" => "x => Ulid.Parse(x.S)",
            _ when IsEnumType(elementType) => $"x => Enum.Parse<{baseType}>(x.S)",
            _ => "x => x.S" // fallback to string
        };
    }

    private static void GenerateRelatedEntityMapping(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Populate related entity properties based on sort key patterns");
        
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty == null)
        {
            sb.AppendLine("            // No sort key defined - cannot map related entities");
            return;
        }
        
        foreach (var relationship in entity.Relationships)
        {
            sb.AppendLine();
            sb.AppendLine($"            // Map related entity: {relationship.PropertyName}");
            
            if (relationship.IsCollection)
            {
                GenerateRelatedEntityCollectionMapping(sb, entity, relationship, sortKeyProperty);
            }
            else
            {
                GenerateRelatedEntitySingleMapping(sb, entity, relationship, sortKeyProperty);
            }
        }
    }

    private static void GenerateRelatedEntityCollectionMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var elementType = GetCollectionElementType(relationship.PropertyType);
        
        sb.AppendLine($"            var {relationship.PropertyName.ToLowerInvariant()}Items = new List<{elementType}>();");
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S ?? string.Empty;");
        
        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);
        
        sb.AppendLine("                    {");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            var relatedEntity = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine($"                            {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of element type
            sb.AppendLine($"                        // Generic mapping to {elementType}");
            sb.AppendLine($"                        var relatedEntity = new {elementType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {elementType}");
            sb.AppendLine($"                        {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
        }
        
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine($"            entity.{relationship.PropertyName} = {relationship.PropertyName.ToLowerInvariant()}Items;");
    }

    private static void GenerateRelatedEntitySingleMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var propertyType = relationship.EntityType ?? GetBaseType(relationship.PropertyType);
        
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S ?? string.Empty;");
        
        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);
        
        sb.AppendLine("                    {");
        
        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            entity.{relationship.PropertyName} = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine("                            break; // Found the related entity");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of property type
            sb.AppendLine($"                        // Generic mapping to {propertyType}");
            sb.AppendLine($"                        entity.{relationship.PropertyName} = new {propertyType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {propertyType}");
            sb.AppendLine("                        break; // Found the related entity");
        }
        
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateSortKeyPatternMatching(StringBuilder sb, string sortKeyPattern)
    {
        if (sortKeyPattern.Contains("*"))
        {
            // Wildcard pattern matching
            var prefix = sortKeyPattern.Replace("*", "");
            sb.AppendLine($"                    if (sortKey.StartsWith(\"{prefix}\"))");
        }
        else
        {
            // Exact pattern matching
            sb.AppendLine($"                    if (sortKey == \"{sortKeyPattern}\" || sortKey.StartsWith(\"{sortKeyPattern}#\"))");
        }
    }

    private static void GenerateComputedKeyLogic(StringBuilder sb, PropertyModel computedProperty)
    {
        var computedKey = computedProperty.ComputedKey!;
        var propertyName = computedProperty.PropertyName;

        if (computedKey.HasCustomFormat)
        {
            // Use custom format string
            var formatArgs = string.Join(", ", computedKey.SourceProperties.Select(sp => $"typedEntity.{sp}"));
            sb.AppendLine($"            typedEntity.{propertyName} = string.Format(\"{computedKey.Format}\", {formatArgs});");
        }
        else
        {
            // Use separator-based concatenation
            var sourceValues = string.Join($" + \"{computedKey.Separator}\" + ", computedKey.SourceProperties.Select(sp => $"typedEntity.{sp}"));
            sb.AppendLine($"            typedEntity.{propertyName} = {sourceValues};");
        }
    }

    private static void GenerateExtractedKeyLogic(StringBuilder sb, PropertyModel extractedProperty)
    {
        var extractedKey = extractedProperty.ExtractedKey!;
        var propertyName = extractedProperty.PropertyName;
        var sourceProperty = extractedKey.SourceProperty;
        var index = extractedKey.Index;
        var separator = extractedKey.Separator;

        sb.AppendLine($"            if (!string.IsNullOrEmpty(entity.{sourceProperty}))");
        sb.AppendLine("            {");
        sb.AppendLine($"                var {sourceProperty.ToLowerInvariant()}Parts = entity.{sourceProperty}.Split('{separator}');");
        sb.AppendLine($"                if ({sourceProperty.ToLowerInvariant()}Parts.Length > {index})");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {sourceProperty.ToLowerInvariant()}Parts[{index}];");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }
}