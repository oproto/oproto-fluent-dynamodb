using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates entity mapping code for converting between C# objects and DynamoDB AttributeValue dictionaries.
/// This is the single, consolidated source of truth for all entity mapping code generation.
/// </summary>
/// <remarks>
/// <para><strong>Architecture:</strong></para>
/// <para>
/// MapperGenerator is responsible for generating all entity mapping logic including:
/// - ToDynamoDb: Converts C# entities to DynamoDB AttributeValue dictionaries
/// - FromDynamoDb: Converts DynamoDB items back to C# entities (single and multi-item overloads)
/// - GetPartitionKey: Extracts partition key from DynamoDB items
/// - MatchesEntity: Determines if a DynamoDB item matches this entity type
/// - GetEntityMetadata: Provides metadata for future LINQ support
/// </para>
/// <para><strong>Performance Optimizations:</strong></para>
/// <list type="bullet">
/// <item><description>Pre-allocated dictionaries: Capacity calculated at compile time to avoid resizing</description></item>
/// <item><description>Aggressive inlining: Hot path methods marked with MethodImpl(AggressiveInlining)</description></item>
/// <item><description>Direct property access: No reflection overhead at runtime</description></item>
/// <item><description>Efficient type conversions: Optimized conversion logic for common types</description></item>
/// </list>
/// <para><strong>Why These Patterns:</strong></para>
/// <list type="bullet">
/// <item><description>Pre-allocated capacity: Dictionary resizing is expensive; knowing the exact size eliminates this cost</description></item>
/// <item><description>AggressiveInlining: Mapping is a hot path; inlining reduces call overhead</description></item>
/// <item><description>Partial class: Allows user code and generated code to coexist seamlessly</description></item>
/// <item><description>Static abstract methods: Enables generic constraints while maintaining AOT compatibility</description></item>
/// </list>
/// </remarks>
public static class MapperGenerator
{
    /// <summary>
    /// Generates the complete entity implementation with IDynamoDbEntity interface methods.
    /// This is the single source of truth for all entity mapping code generation.
    /// </summary>
    /// <param name="entity">The entity model to generate mapping code for.</param>
    /// <returns>The generated C# source code.</returns>
    public static string GenerateEntityImplementation(EntityModel entity)
    {
        var sb = new StringBuilder();

        // File header with auto-generated comment
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This code was generated by the DynamoDB Source Generator.");
        sb.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        sb.AppendLine();

        // All necessary using statements
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.IO;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Amazon.DynamoDBv2.Model;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine();

        // Namespace declaration
        sb.AppendLine($"namespace {entity.Namespace}");
        sb.AppendLine("{");

        // XML documentation
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated implementation of IDynamoDbEntity for {entity.ClassName}.");
        sb.AppendLine($"    /// Provides automatic mapping between C# objects and DynamoDB AttributeValue dictionaries.");
        sb.AppendLine($"    /// Table: {entity.TableName}");
        if (entity.IsMultiItemEntity)
        {
            sb.AppendLine($"    /// Multi-item entity: Supports entities that span multiple DynamoDB items.");
        }
        if (entity.Relationships.Length > 0)
        {
            sb.AppendLine($"    /// Related entities: {entity.Relationships.Length} relationship(s) defined.");
        }
        sb.AppendLine($"    /// </summary>");

        // Class declaration - partial class with IDynamoDbEntity interface
        sb.AppendLine($"    public partial class {entity.ClassName} : IDynamoDbEntity");
        sb.AppendLine("    {");

        // Check if entity has blob reference properties
        var hasBlobReferences = entity.Properties.Any(p => p.AdvancedType?.IsBlobReference == true);

        // Generate all required interface methods
        if (hasBlobReferences)
        {
            // Generate async methods for entities with blob references
            GenerateToDynamoDbAsyncMethod(sb, entity);
            GenerateFromDynamoDbSingleAsyncMethod(sb, entity);
            GenerateFromDynamoDbMultiAsyncMethod(sb, entity);
        }
        else
        {
            // Generate synchronous methods for entities without blob references
            GenerateToDynamoDbMethod(sb, entity);
            GenerateFromDynamoDbSingleMethod(sb, entity);
            GenerateFromDynamoDbMultiMethod(sb, entity);
        }

        GenerateGetPartitionKeyMethod(sb, entity);
        GenerateMatchesEntityMethod(sb, entity);
        GenerateGetEntityMetadataMethod(sb, entity);

        // Closing braces for class and namespace
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateToDynamoDbMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// High-performance conversion from entity to DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// Optimized for minimal allocations and maximum throughput.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"entity\">The entity instance to convert.</param>");
        sb.AppendLine("        /// <returns>A dictionary of DynamoDB AttributeValues representing the entity.</returns>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static Dictionary<string, AttributeValue> ToDynamoDb<TSelf>(TSelf entity) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();

        // Pre-compute capacity to avoid dictionary resizing (performance optimization)
        var attributeCount = entity.Properties.Count(p => p.HasAttributeMapping);
        sb.AppendLine($"            // Pre-allocate dictionary with exact capacity to avoid resizing");
        sb.AppendLine($"            var item = new Dictionary<string, AttributeValue>({attributeCount});");
        sb.AppendLine();

        // Generate computed key logic before mapping
        var computedProperties = entity.Properties.Where(p => p.IsComputed).ToArray();
        if (computedProperties.Length > 0)
        {
            sb.AppendLine("            // Compute composite keys before mapping");
            foreach (var computedProperty in computedProperties)
            {
                GenerateComputedKeyLogic(sb, computedProperty);
            }
            sb.AppendLine();
        }

        // Generate property mappings for all properties
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyToAttributeValue(sb, property, entity);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
    }

    private static void GenerateToDynamoDbAsyncMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// High-performance async conversion from entity to DynamoDB AttributeValue dictionary.");
        sb.AppendLine("        /// Handles blob reference properties by storing data externally and saving references.");
        sb.AppendLine("        /// Optimized for minimal allocations and maximum throughput.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"entity\">The entity instance to convert.</param>");
        sb.AppendLine("        /// <param name=\"blobProvider\">The blob storage provider for handling blob references.</param>");
        sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token for async operations.</param>");
        sb.AppendLine("        /// <returns>A task that resolves to a dictionary of DynamoDB AttributeValues representing the entity.</returns>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static async Task<Dictionary<string, AttributeValue>> ToDynamoDbAsync<TSelf>(");
        sb.AppendLine("            TSelf entity,");
        sb.AppendLine("            IBlobStorageProvider blobProvider,");
        sb.AppendLine("            CancellationToken cancellationToken = default) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (entity is not {entity.ClassName} typedEntity)");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{entity.GetType().Name}}\", nameof(entity));");
        sb.AppendLine();
        sb.AppendLine("            if (blobProvider == null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(blobProvider), \"Blob provider is required for entities with blob reference properties\");");
        sb.AppendLine();

        // Pre-compute capacity to avoid dictionary resizing (performance optimization)
        var attributeCount = entity.Properties.Count(p => p.HasAttributeMapping);
        sb.AppendLine($"            // Pre-allocate dictionary with exact capacity to avoid resizing");
        sb.AppendLine($"            var item = new Dictionary<string, AttributeValue>({attributeCount});");
        sb.AppendLine();

        // Generate computed key logic before mapping
        var computedProperties = entity.Properties.Where(p => p.IsComputed).ToArray();
        if (computedProperties.Length > 0)
        {
            sb.AppendLine("            // Compute composite keys before mapping");
            foreach (var computedProperty in computedProperties)
            {
                GenerateComputedKeyLogic(sb, computedProperty);
            }
            sb.AppendLine();
        }

        // Generate property mappings for all properties
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyToAttributeValueAsync(sb, property, entity);
        }

        sb.AppendLine();
        sb.AppendLine("            return item;");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyToAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;

        // Handle TTL properties (Time-To-Live)
        if (property.AdvancedType?.IsTtl == true)
        {
            GenerateTtlPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle JSON blob properties
        if (property.AdvancedType?.IsJsonBlob == true)
        {
            GenerateJsonBlobPropertyToAttributeValue(sb, property, entity);
            return;
        }

        // Handle Map properties (Dictionary types)
        if (property.AdvancedType?.IsMap == true)
        {
            GenerateMapPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle collection properties differently for single-item entities
        if (property.IsCollection)
        {
            GenerateCollectionPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle nullable properties
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    private static void GeneratePropertyToAttributeValueAsync(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;

        // Handle blob reference properties (async)
        if (property.AdvancedType?.IsBlobReference == true)
        {
            GenerateBlobReferencePropertyToAttributeValue(sb, property, entity);
            return;
        }

        // Handle TTL properties (Time-To-Live)
        if (property.AdvancedType?.IsTtl == true)
        {
            GenerateTtlPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle JSON blob properties
        if (property.AdvancedType?.IsJsonBlob == true)
        {
            GenerateJsonBlobPropertyToAttributeValue(sb, property, entity);
            return;
        }

        // Handle Map properties (Dictionary types)
        if (property.AdvancedType?.IsMap == true)
        {
            GenerateMapPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle collection properties differently for single-item entities
        if (property.IsCollection)
        {
            GenerateCollectionPropertyToAttributeValue(sb, property);
            return;
        }

        // Handle nullable properties
        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            item[\"{attributeName}\"] = {GetToAttributeValueExpression(property, $"typedEntity.{propertyName}")};");
        }
    }

    private static void GenerateBlobReferencePropertyToAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;
        var baseType = GetBaseType(propertyType);

        sb.AppendLine($"            // Store blob reference property {propertyName} externally");
        sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");

        // Convert property to stream based on type
        if (baseType == "byte[]" || baseType == "System.Byte[]")
        {
            // byte[] - convert to MemoryStream
            sb.AppendLine($"                    using var stream = new MemoryStream(typedEntity.{propertyName});");
        }
        else if (baseType == "Stream" || baseType == "System.IO.Stream" || baseType == "MemoryStream")
        {
            // Already a stream - use directly
            sb.AppendLine($"                    var stream = typedEntity.{propertyName};");
        }
        else if (baseType == "string" || baseType == "System.String")
        {
            // string - convert to UTF8 bytes then stream
            sb.AppendLine($"                    var bytes = System.Text.Encoding.UTF8.GetBytes(typedEntity.{propertyName});");
            sb.AppendLine("                    using var stream = new MemoryStream(bytes);");
        }
        else
        {
            // Complex type - serialize to JSON first, then to stream
            sb.AppendLine($"                    // Serialize complex type to JSON");
            sb.AppendLine($"                    var json = System.Text.Json.JsonSerializer.Serialize(typedEntity.{propertyName});");
            sb.AppendLine("                    var bytes = System.Text.Encoding.UTF8.GetBytes(json);");
            sb.AppendLine("                    using var stream = new MemoryStream(bytes);");
        }

        // Generate suggested key based on entity keys
        var partitionKeyProperty = entity.Properties.FirstOrDefault(p => p.IsPartitionKey);
        var sortKeyProperty = entity.Properties.FirstOrDefault(p => p.IsSortKey);

        if (partitionKeyProperty != null)
        {
            if (sortKeyProperty != null)
            {
                sb.AppendLine($"                    var suggestedKey = $\"{{typedEntity.{partitionKeyProperty.PropertyName}}}/{{typedEntity.{sortKeyProperty.PropertyName}}}/{propertyName}\";");
            }
            else
            {
                sb.AppendLine($"                    var suggestedKey = $\"{{typedEntity.{partitionKeyProperty.PropertyName}}}/{propertyName}\";");
            }
        }
        else
        {
            sb.AppendLine($"                    var suggestedKey = $\"{propertyName}/{{Guid.NewGuid()}}\";");
        }

        // Store blob and save reference
        sb.AppendLine("                    var reference = await blobProvider.StoreAsync(stream, suggestedKey, cancellationToken);");
        sb.AppendLine($"                    item[\"{attributeName}\"] = new AttributeValue {{ S = reference }};");

        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        new AttributeValue {{ S = \"<blob data>\" }},");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateTtlPropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;
        var baseType = GetBaseType(propertyType);

        sb.AppendLine($"            // Convert TTL property {propertyName} to Unix epoch seconds");

        if (baseType == "DateTime" || baseType == "System.DateTime")
        {
            // DateTime TTL conversion
            if (property.IsNullable)
            {
                sb.AppendLine($"            if (typedEntity.{propertyName}.HasValue)");
                sb.AppendLine("            {");
                sb.AppendLine("                var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);");
                sb.AppendLine($"                var seconds = (long)(typedEntity.{propertyName}.Value.ToUniversalTime() - epoch).TotalSeconds;");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ N = seconds.ToString() }};");
                sb.AppendLine("            }");
            }
            else
            {
                sb.AppendLine("            {");
                sb.AppendLine("                var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);");
                sb.AppendLine($"                var seconds = (long)(typedEntity.{propertyName}.ToUniversalTime() - epoch).TotalSeconds;");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ N = seconds.ToString() }};");
                sb.AppendLine("            }");
            }
        }
        else if (baseType == "DateTimeOffset" || baseType == "System.DateTimeOffset")
        {
            // DateTimeOffset TTL conversion
            if (property.IsNullable)
            {
                sb.AppendLine($"            if (typedEntity.{propertyName}.HasValue)");
                sb.AppendLine("            {");
                sb.AppendLine($"                var seconds = typedEntity.{propertyName}.Value.ToUnixTimeSeconds();");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ N = seconds.ToString() }};");
                sb.AppendLine("            }");
            }
            else
            {
                sb.AppendLine("            {");
                sb.AppendLine($"                var seconds = typedEntity.{propertyName}.ToUnixTimeSeconds();");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ N = seconds.ToString() }};");
                sb.AppendLine("            }");
            }
        }
    }

    private static void GenerateJsonBlobPropertyToAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var serializerType = property.AdvancedType?.JsonSerializerType;

        sb.AppendLine($"            // Serialize JSON blob property {propertyName}");

        if (property.IsNullable)
        {
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");

            if (serializerType == "SystemTextJson")
            {
                // Use System.Text.Json with generated JsonSerializerContext
                var baseType = GetBaseType(property.PropertyType);
                sb.AppendLine($"                var json = System.Text.Json.JsonSerializer.Serialize(");
                sb.AppendLine($"                    typedEntity.{propertyName},");
                sb.AppendLine($"                    {entity.ClassName}JsonContext.Default.{baseType});");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ S = json }};");
            }
            else if (serializerType == "NewtonsoftJson")
            {
                // Use Newtonsoft.Json
                sb.AppendLine($"                var json = Newtonsoft.Json.JsonConvert.SerializeObject(typedEntity.{propertyName});");
                sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ S = json }};");
            }

            sb.AppendLine("            }");
        }
        else
        {
            if (serializerType == "SystemTextJson")
            {
                // Use System.Text.Json with generated JsonSerializerContext
                var baseType = GetBaseType(property.PropertyType);
                sb.AppendLine($"            var json = System.Text.Json.JsonSerializer.Serialize(");
                sb.AppendLine($"                typedEntity.{propertyName},");
                sb.AppendLine($"                {entity.ClassName}JsonContext.Default.{baseType});");
                sb.AppendLine($"            item[\"{attributeName}\"] = new AttributeValue {{ S = json }};");
            }
            else if (serializerType == "NewtonsoftJson")
            {
                // Use Newtonsoft.Json
                sb.AppendLine($"            var json = Newtonsoft.Json.JsonConvert.SerializeObject(typedEntity.{propertyName});");
                sb.AppendLine($"            item[\"{attributeName}\"] = new AttributeValue {{ S = json }};");
            }
        }
    }

    private static void GenerateTtlPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;
        var baseType = GetBaseType(propertyType);

        sb.AppendLine($"            // Convert TTL property {propertyName} from Unix epoch seconds");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.N != null)");
        sb.AppendLine("                    {");

        if (baseType == "DateTime" || baseType == "System.DateTime")
        {
            // DateTime TTL reconstruction
            sb.AppendLine($"                        var seconds = long.Parse({propertyName.ToLowerInvariant()}Value.N);");
            sb.AppendLine("                        var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);");
            sb.AppendLine($"                        entity.{propertyName} = epoch.AddSeconds(seconds);");
        }
        else if (baseType == "DateTimeOffset" || baseType == "System.DateTimeOffset")
        {
            // DateTimeOffset TTL reconstruction
            sb.AppendLine($"                        var seconds = long.Parse({propertyName.ToLowerInvariant()}Value.N);");
            sb.AppendLine($"                        entity.{propertyName} = DateTimeOffset.FromUnixTimeSeconds(seconds);");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateJsonBlobPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;
        var baseType = GetBaseType(propertyType);
        var serializerType = property.AdvancedType?.JsonSerializerType;

        sb.AppendLine($"            // Deserialize JSON blob property {propertyName}");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.S != null)");
        sb.AppendLine("                    {");

        if (serializerType == "SystemTextJson")
        {
            // Use System.Text.Json with generated JsonSerializerContext
            sb.AppendLine($"                        entity.{propertyName} = System.Text.Json.JsonSerializer.Deserialize(");
            sb.AppendLine($"                            {propertyName.ToLowerInvariant()}Value.S,");
            sb.AppendLine($"                            {entity.ClassName}JsonContext.Default.{baseType});");
        }
        else if (serializerType == "NewtonsoftJson")
        {
            // Use Newtonsoft.Json
            sb.AppendLine($"                        entity.{propertyName} = Newtonsoft.Json.JsonConvert.DeserializeObject<{baseType}>({propertyName.ToLowerInvariant()}Value.S);");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateMapPropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;

        sb.AppendLine($"            // Convert Map property {propertyName} to DynamoDB Map (M)");
        sb.AppendLine($"            // Note: Custom types use nested ToDynamoDb calls (NO REFLECTION) for AOT compatibility");

        // Check if it's Dictionary<string, string>
        if (propertyType.Contains("Dictionary<string, string>") || 
            propertyType.Contains("Dictionary<System.String, System.String>"))
        {
            // Dictionary<string, string> - simple string map
            sb.AppendLine($"            if (typedEntity.{propertyName} != null && typedEntity.{propertyName}.Count > 0)");
            sb.AppendLine("            {");
            sb.AppendLine($"                var {propertyName.ToLowerInvariant()}Map = new Dictionary<string, AttributeValue>();");
            sb.AppendLine($"                foreach (var kvp in typedEntity.{propertyName})");
            sb.AppendLine("                {");
            sb.AppendLine($"                    {propertyName.ToLowerInvariant()}Map[kvp.Key] = new AttributeValue {{ S = kvp.Value }};");
            sb.AppendLine("                }");
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ M = {propertyName.ToLowerInvariant()}Map }};");
            sb.AppendLine("            }");
        }
        // Check if it's Dictionary<string, AttributeValue>
        else if (propertyType.Contains("Dictionary<string, AttributeValue>") ||
                 propertyType.Contains("Dictionary<System.String, Amazon.DynamoDBv2.Model.AttributeValue>"))
        {
            // Dictionary<string, AttributeValue> - direct map
            sb.AppendLine($"            if (typedEntity.{propertyName} != null && typedEntity.{propertyName}.Count > 0)");
            sb.AppendLine("            {");
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue {{ M = typedEntity.{propertyName} }};");
            sb.AppendLine("            }");
        }
        else
        {
            // Custom object with [DynamoDbMap] - use nested ToDynamoDb call
            // The nested type must also be marked with [DynamoDbEntity] to have its own mapping generated
            sb.AppendLine($"            if (typedEntity.{propertyName} != null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                // Convert nested entity to map using its generated ToDynamoDb method");
            sb.AppendLine($"                var {propertyName.ToLowerInvariant()}Map = {propertyType}.ToDynamoDb(typedEntity.{propertyName});");
            sb.AppendLine($"                if ({propertyName.ToLowerInvariant()}Map != null && {propertyName.ToLowerInvariant()}Map.Count > 0)");
            sb.AppendLine("                {");
            sb.AppendLine($"                    item[\"{attributeName}\"] = new AttributeValue {{ M = {propertyName.ToLowerInvariant()}Map }};");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
        }
    }

    private static void GenerateCollectionPropertyToAttributeValue(StringBuilder sb, PropertyModel property)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var collectionElementType = GetCollectionElementType(property.PropertyType);

        sb.AppendLine($"            // Convert collection {propertyName} to native DynamoDB type");
        sb.AppendLine($"            if (typedEntity.{propertyName} != null && typedEntity.{propertyName}.Count > 0)");
        sb.AppendLine("            {");

        // Check if this is a Set type (HashSet)
        var isSet = property.PropertyType.Contains("HashSet<") || 
                    property.PropertyType.Contains("System.Collections.Generic.HashSet<");

        if (isSet)
        {
            // Generate Set-specific code (SS, NS, or BS)
            GenerateSetPropertyToAttributeValue(sb, property, attributeName, propertyName, collectionElementType);
        }
        else
        {
            // Generate List-specific code (L)
            GenerateListPropertyToAttributeValue(sb, property, attributeName, propertyName, collectionElementType);
        }

        sb.AppendLine("            }");
    }

    private static void GenerateSetPropertyToAttributeValue(StringBuilder sb, PropertyModel property, string attributeName, string propertyName, string collectionElementType)
    {
        var baseElementType = GetBaseType(collectionElementType);

        if (baseElementType == "string" || baseElementType == "System.String")
        {
            // String Set (SS)
            sb.AppendLine($"                // Convert HashSet<string> to DynamoDB String Set (SS)");
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    SS = typedEntity.{propertyName}.ToList()");
            sb.AppendLine("                };");
        }
        else if (IsNumericType(baseElementType))
        {
            // Number Set (NS)
            sb.AppendLine($"                // Convert HashSet<{baseElementType}> to DynamoDB Number Set (NS)");
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    NS = typedEntity.{propertyName}.Select(x => x.ToString()).ToList()");
            sb.AppendLine("                };");
        }
        else if (baseElementType == "byte[]" || baseElementType == "System.Byte[]")
        {
            // Binary Set (BS)
            sb.AppendLine($"                // Convert HashSet<byte[]> to DynamoDB Binary Set (BS)");
            sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
            sb.AppendLine("                {");
            sb.AppendLine($"                    BS = typedEntity.{propertyName}.Select(x => new MemoryStream(x)).ToList()");
            sb.AppendLine("                };");
        }
        else
        {
            // Unsupported Set element type - this should be caught by validation
            sb.AppendLine($"                // ERROR: Unsupported Set element type: {baseElementType}");
            sb.AppendLine($"                // DynamoDB Sets only support string, number, and binary types");
            sb.AppendLine($"                throw new NotSupportedException($\"HashSet<{baseElementType}> is not supported. Use HashSet<string>, HashSet<int>, HashSet<decimal>, or HashSet<byte[]>\");");
        }
    }

    private static void GenerateListPropertyToAttributeValue(StringBuilder sb, PropertyModel property, string attributeName, string propertyName, string collectionElementType)
    {
        var baseElementType = GetBaseType(collectionElementType);

        // Use List (L) for all List types
        sb.AppendLine($"                // Convert List<{baseElementType}> to DynamoDB List (L)");
        sb.AppendLine($"                item[\"{attributeName}\"] = new AttributeValue");
        sb.AppendLine("                {");
        sb.AppendLine($"                    L = typedEntity.{propertyName}.Select(x => {GetToAttributeValueExpressionForCollectionElement(collectionElementType, "x")}).ToList()");
        sb.AppendLine("                };");
    }

    private static string GetToAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);

        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" or "System.Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "byte[]" or "System.Byte[]" => $"new AttributeValue {{ B = new System.IO.MemoryStream({valueExpression}) }}",
            _ when IsEnumType(property.PropertyType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression} != null ? {valueExpression}.ToString() : \"\" }}"
        };
    }

    private static void GenerateFromDynamoDbSingleMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// High-performance conversion from DynamoDB item to entity with minimal boxing and allocations.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"item\">The DynamoDB item to map from.</param>");
        sb.AppendLine("        /// <returns>A mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when the type parameter doesn't match the entity type.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(Dictionary<string, AttributeValue> item) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{typeof(TSelf).Name}}\");");
        sb.AppendLine();

        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate property mappings
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyFromAttributeValue(sb, property, entity);
        }

        // Generate extracted key logic
        var extractedProperties = entity.Properties.Where(p => p.IsExtracted).ToArray();
        if (extractedProperties.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("            // Extract component properties from composite keys");
            foreach (var extractedProperty in extractedProperties)
            {
                GenerateExtractedKeyLogic(sb, extractedProperty);
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    private static void GenerateFromDynamoDbSingleAsyncMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// High-performance async conversion from DynamoDB item to entity with minimal boxing and allocations.");
        sb.AppendLine("        /// Handles blob reference properties by retrieving data from external storage.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"item\">The DynamoDB item to map from.</param>");
        sb.AppendLine("        /// <param name=\"blobProvider\">The blob storage provider for handling blob references.</param>");
        sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token for async operations.</param>");
        sb.AppendLine("        /// <returns>A task that resolves to a mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when the type parameter doesn't match the entity type.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static async Task<TSelf> FromDynamoDbAsync<TSelf>(");
        sb.AppendLine("            Dictionary<string, AttributeValue> item,");
        sb.AppendLine("            IBlobStorageProvider blobProvider,");
        sb.AppendLine("            CancellationToken cancellationToken = default) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (typeof(TSelf) != typeof({entity.ClassName}))");
        sb.AppendLine($"                throw new ArgumentException($\"Expected {entity.ClassName}, got {{typeof(TSelf).Name}}\");");
        sb.AppendLine();
        sb.AppendLine("            if (blobProvider == null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(blobProvider), \"Blob provider is required for entities with blob reference properties\");");
        sb.AppendLine();

        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // Generate property mappings
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyFromAttributeValueAsync(sb, property, entity);
        }

        // Generate extracted key logic
        var extractedProperties = entity.Properties.Where(p => p.IsExtracted).ToArray();
        if (extractedProperties.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("            // Extract component properties from composite keys");
            foreach (var extractedProperty in extractedProperties)
            {
                GenerateExtractedKeyLogic(sb, extractedProperty);
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return (TSelf)(object)entity;");
        sb.AppendLine("        }");
    }

    private static void GenerateFromDynamoDbMultiAsyncMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from multiple DynamoDB items (composite entity support).");
        sb.AppendLine("        /// For single-item entities, uses the first item. For multi-item entities, combines all items.");
        sb.AppendLine("        /// Handles blob reference properties by retrieving data from external storage.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"items\">The collection of DynamoDB items to map from.</param>");
        sb.AppendLine("        /// <param name=\"blobProvider\">The blob storage provider for handling blob references.</param>");
        sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token for async operations.</param>");
        sb.AppendLine("        /// <returns>A task that resolves to a mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when items collection is null or empty.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static async Task<TSelf> FromDynamoDbAsync<TSelf>(");
        sb.AppendLine("            IList<Dictionary<string, AttributeValue>> items,");
        sb.AppendLine("            IBlobStorageProvider blobProvider,");
        sb.AppendLine("            CancellationToken cancellationToken = default) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            if (items == null || items.Count == 0)");
        sb.AppendLine($"                throw new ArgumentException(\"Items collection cannot be null or empty\", nameof(items));");
        sb.AppendLine();
        sb.AppendLine("            if (blobProvider == null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(blobProvider), \"Blob provider is required for entities with blob reference properties\");");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (entity.IsMultiItemEntity)
        {
            sb.AppendLine("                // Multi-item entity: combine all items into a single entity");
            sb.AppendLine("                // Note: Multi-item entities with blob references not yet fully supported");
            sb.AppendLine("                return await FromDynamoDbAsync<TSelf>(items[0], blobProvider, cancellationToken);");
        }
        else
        {
            sb.AppendLine("                // Single-item entity: use the first item");
            sb.AppendLine("                return await FromDynamoDbAsync<TSelf>(items[0], blobProvider, cancellationToken);");
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (DynamoDbMappingException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Re-throw mapping exceptions as-is");
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                throw DynamoDbMappingException.EntityConstructionFailed(");
        sb.AppendLine($"                    typeof({entity.ClassName}),");
        sb.AppendLine("                    items.FirstOrDefault() ?? new Dictionary<string, AttributeValue>(),");
        sb.AppendLine("                    ex)");
        sb.AppendLine("                    .WithContext(\"ItemCount\", items.Count)");
        sb.AppendLine("                    .WithContext(\"MappingType\", \"MultiItem\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;

        // Handle TTL properties (Time-To-Live)
        if (property.AdvancedType?.IsTtl == true)
        {
            GenerateTtlPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        // Handle JSON blob properties
        if (property.AdvancedType?.IsJsonBlob == true)
        {
            GenerateJsonBlobPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        // Handle Map properties (Dictionary types)
        if (property.AdvancedType?.IsMap == true)
        {
            GenerateMapPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        if (property.IsCollection)
        {
            GenerateCollectionPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {GetFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GeneratePropertyFromAttributeValueAsync(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;

        // Handle blob reference properties (async)
        if (property.AdvancedType?.IsBlobReference == true)
        {
            GenerateBlobReferencePropertyFromAttributeValue(sb, property, entity);
            return;
        }

        // Handle TTL properties (Time-To-Live)
        if (property.AdvancedType?.IsTtl == true)
        {
            GenerateTtlPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        // Handle JSON blob properties
        if (property.AdvancedType?.IsJsonBlob == true)
        {
            GenerateJsonBlobPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        // Handle Map properties (Dictionary types)
        if (property.AdvancedType?.IsMap == true)
        {
            GenerateMapPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        if (property.IsCollection)
        {
            GenerateCollectionPropertyFromAttributeValue(sb, property, entity);
            return;
        }

        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {GetFromAttributeValueExpression(property, $"{propertyName.ToLowerInvariant()}Value")};");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateBlobReferencePropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;
        var baseType = GetBaseType(propertyType);

        sb.AppendLine($"            // Retrieve blob reference property {propertyName} from external storage");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.S != null)");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        var reference = {propertyName.ToLowerInvariant()}Value.S;");
        sb.AppendLine("                        var stream = await blobProvider.RetrieveAsync(reference, cancellationToken);");
        sb.AppendLine();

        // Convert stream back to property type
        if (baseType == "byte[]" || baseType == "System.Byte[]")
        {
            // byte[] - read stream to byte array
            sb.AppendLine("                        using var memoryStream = new MemoryStream();");
            sb.AppendLine("                        await stream.CopyToAsync(memoryStream, cancellationToken);");
            sb.AppendLine($"                        entity.{propertyName} = memoryStream.ToArray();");
        }
        else if (baseType == "Stream" || baseType == "System.IO.Stream" || baseType == "MemoryStream")
        {
            // Stream - use directly (caller must manage disposal)
            sb.AppendLine($"                        entity.{propertyName} = stream;");
        }
        else if (baseType == "string" || baseType == "System.String")
        {
            // string - read stream as UTF8 string
            sb.AppendLine("                        using var reader = new StreamReader(stream);");
            sb.AppendLine($"                        entity.{propertyName} = await reader.ReadToEndAsync();");
        }
        else
        {
            // Complex type - deserialize from JSON
            sb.AppendLine("                        // Deserialize complex type from JSON");
            sb.AppendLine("                        using var reader = new StreamReader(stream);");
            sb.AppendLine("                        var json = await reader.ReadToEndAsync();");
            sb.AppendLine($"                        entity.{propertyName} = System.Text.Json.JsonSerializer.Deserialize<{baseType}>(json);");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        ex)");
        sb.AppendLine($"                        .WithContext(\"BlobReference\", {propertyName.ToLowerInvariant()}Value.S ?? \"<null>\");");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateMapPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var propertyType = property.PropertyType;

        sb.AppendLine($"            // Convert Map property {propertyName} from DynamoDB Map (M)");
        sb.AppendLine($"            // Note: Custom types use nested FromDynamoDb calls (NO REFLECTION) for AOT compatibility");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.M != null && {propertyName.ToLowerInvariant()}Value.M.Count > 0)");
        sb.AppendLine("                    {");

        // Check if it's Dictionary<string, string>
        if (propertyType.Contains("Dictionary<string, string>") || 
            propertyType.Contains("Dictionary<System.String, System.String>"))
        {
            // Dictionary<string, string> - reconstruct from string map
            sb.AppendLine($"                        entity.{propertyName} = {propertyName.ToLowerInvariant()}Value.M.ToDictionary(");
            sb.AppendLine("                            kvp => kvp.Key,");
            sb.AppendLine("                            kvp => kvp.Value.S);");
        }
        // Check if it's Dictionary<string, AttributeValue>
        else if (propertyType.Contains("Dictionary<string, AttributeValue>") ||
                 propertyType.Contains("Dictionary<System.String, Amazon.DynamoDBv2.Model.AttributeValue>"))
        {
            // Dictionary<string, AttributeValue> - direct assignment
            sb.AppendLine($"                        entity.{propertyName} = {propertyName.ToLowerInvariant()}Value.M;");
        }
        else
        {
            // Custom object with [DynamoDbMap] - use nested FromDynamoDb call
            // The nested type must also be marked with [DynamoDbEntity] to have its own mapping generated
            sb.AppendLine($"                        // Convert map back to nested entity using its generated FromDynamoDb method");
            sb.AppendLine($"                        entity.{propertyName} = {propertyType}.FromDynamoDb<{propertyType}>({propertyName.ToLowerInvariant()}Value.M);");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({property.PropertyType}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateCollectionPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, EntityModel entity)
    {
        var attributeName = property.AttributeName;
        var propertyName = property.PropertyName;
        var collectionElementType = GetCollectionElementType(property.PropertyType);
        var baseElementType = GetBaseType(collectionElementType);

        sb.AppendLine($"            // Convert collection {propertyName} from native DynamoDB type");
        sb.AppendLine($"            if (item.TryGetValue(\"{attributeName}\", out var {propertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("            {");
        sb.AppendLine($"                try");
        sb.AppendLine("                {");

        // Check if this is a Set type (HashSet)
        var isSet = property.PropertyType.Contains("HashSet<") || 
                    property.PropertyType.Contains("System.Collections.Generic.HashSet<");

        if (isSet)
        {
            // Generate Set-specific code (SS, NS, or BS)
            GenerateSetPropertyFromAttributeValue(sb, property, propertyName, baseElementType);
        }
        else
        {
            // Generate List-specific code (L)
            GenerateListPropertyFromAttributeValue(sb, property, propertyName, collectionElementType);
        }

        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    throw DynamoDbMappingException.PropertyConversionFailed(");
        sb.AppendLine($"                        typeof({entity.ClassName}),");
        sb.AppendLine($"                        \"{propertyName}\",");
        sb.AppendLine($"                        {propertyName.ToLowerInvariant()}Value,");
        sb.AppendLine($"                        typeof({property.PropertyType}),");
        sb.AppendLine("                        ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                // Initialize empty collection if no data found");
        sb.AppendLine($"                entity.{propertyName} = new {property.PropertyType}();");
        sb.AppendLine("            }");
    }

    private static void GenerateSetPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, string propertyName, string baseElementType)
    {
        if (baseElementType == "string" || baseElementType == "System.String")
        {
            // String Set (SS)
            sb.AppendLine($"                    // Convert DynamoDB String Set (SS) to HashSet<string>");
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.SS != null && {propertyName.ToLowerInvariant()}Value.SS.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.SS);");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        else if (IsNumericType(baseElementType))
        {
            // Number Set (NS)
            sb.AppendLine($"                    // Convert DynamoDB Number Set (NS) to HashSet<{baseElementType}>");
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.NS != null && {propertyName.ToLowerInvariant()}Value.NS.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.NS.Select({GetNumericConversionExpression(baseElementType)}));");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        else if (baseElementType == "byte[]" || baseElementType == "System.Byte[]")
        {
            // Binary Set (BS)
            sb.AppendLine($"                    // Convert DynamoDB Binary Set (BS) to HashSet<byte[]>");
            sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.BS != null && {propertyName.ToLowerInvariant()}Value.BS.Count > 0)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.BS.Select(x => x.ToArray()));");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
            sb.AppendLine("                    }");
        }
        else
        {
            // Unsupported Set element type
            sb.AppendLine($"                    // ERROR: Unsupported Set element type: {baseElementType}");
            sb.AppendLine($"                    throw new NotSupportedException($\"HashSet<{baseElementType}> is not supported. Use HashSet<string>, HashSet<int>, HashSet<decimal>, or HashSet<byte[]>\");");
        }
    }

    private static void GenerateListPropertyFromAttributeValue(StringBuilder sb, PropertyModel property, string propertyName, string collectionElementType)
    {
        // Handle List (L) for all List types
        sb.AppendLine($"                    // Convert DynamoDB List (L) to List<{collectionElementType}>");
        sb.AppendLine($"                    if ({propertyName.ToLowerInvariant()}Value.L != null && {propertyName.ToLowerInvariant()}Value.L.Count > 0)");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}({propertyName.ToLowerInvariant()}Value.L.Select({GetFromAttributeValueExpressionForCollectionElement(collectionElementType)}));");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        entity.{propertyName} = new {property.PropertyType}();");
        sb.AppendLine("                    }");
    }

    private static string GetFromAttributeValueExpression(PropertyModel property, string valueExpression)
    {
        var baseType = GetBaseType(property.PropertyType);
        var isNullable = property.IsNullable;

        var conversion = baseType switch
        {
            "string" => $"{valueExpression}.S",
            "int" or "System.Int32" => $"int.Parse({valueExpression}.N)",
            "long" or "System.Int64" => $"long.Parse({valueExpression}.N)",
            "double" or "System.Double" => $"double.Parse({valueExpression}.N)",
            "float" or "System.Single" => $"float.Parse({valueExpression}.N)",
            "decimal" or "System.Decimal" => $"decimal.Parse({valueExpression}.N)",
            "bool" or "System.Boolean" => $"{valueExpression}.BOOL",
            "DateTime" or "System.DateTime" => $"DateTime.Parse({valueExpression}.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => $"DateTimeOffset.Parse({valueExpression}.S)",
            "Guid" or "System.Guid" => $"Guid.Parse({valueExpression}.S)",
            "Ulid" or "System.Ulid" => $"Ulid.Parse({valueExpression}.S)",
            "byte[]" or "System.Byte[]" => $"{valueExpression}.B.ToArray()",
            _ when IsEnumType(property.PropertyType) => $"Enum.Parse<{baseType}>({valueExpression}.S)",
            _ => $"{valueExpression}.S"
        };

        return conversion;
    }

    private static void GenerateFromDynamoDbMultiMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an entity instance from multiple DynamoDB items (composite entity support).");
        sb.AppendLine("        /// For single-item entities, uses the first item. For multi-item entities, combines all items.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TSelf\">The entity type implementing IDynamoDbEntity.</typeparam>");
        sb.AppendLine("        /// <param name=\"items\">The collection of DynamoDB items to map from.</param>");
        sb.AppendLine("        /// <returns>A mapped entity instance.</returns>");
        sb.AppendLine("        /// <exception cref=\"ArgumentException\">Thrown when items collection is null or empty.</exception>");
        sb.AppendLine("        /// <exception cref=\"DynamoDbMappingException\">Thrown when mapping fails due to data conversion issues.</exception>");
        sb.AppendLine($"        public static TSelf FromDynamoDb<TSelf>(IList<Dictionary<string, AttributeValue>> items) where TSelf : IDynamoDbEntity");
        sb.AppendLine("        {");
        sb.AppendLine("            if (items == null || items.Count == 0)");
        sb.AppendLine($"                throw new ArgumentException(\"Items collection cannot be null or empty\", nameof(items));");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (entity.IsMultiItemEntity)
        {
            GenerateMultiItemFromDynamoDb(sb, entity);
        }
        else
        {
            sb.AppendLine("                // Single-item entity: use the first item");
            sb.AppendLine("                return FromDynamoDb<TSelf>(items[0]);");
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (DynamoDbMappingException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Re-throw mapping exceptions as-is");
        sb.AppendLine("                throw;");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                throw DynamoDbMappingException.EntityConstructionFailed(");
        sb.AppendLine($"                    typeof({entity.ClassName}),");
        sb.AppendLine("                    items.FirstOrDefault() ?? new Dictionary<string, AttributeValue>(),");
        sb.AppendLine("                    ex)");
        sb.AppendLine("                    .WithContext(\"ItemCount\", items.Count)");
        sb.AppendLine("                    .WithContext(\"MappingType\", \"MultiItem\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void GenerateMultiItemFromDynamoDb(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Multi-item entity: combine all items into a single entity");
        sb.AppendLine($"            var entity = new {entity.ClassName}();");
        sb.AppendLine();

        // First, populate non-collection properties from the first item (or any item that has them)
        var nonCollectionProperties = entity.Properties.Where(p => p.HasAttributeMapping && !p.IsCollection).ToArray();
        if (nonCollectionProperties.Length > 0)
        {
            sb.AppendLine("            // Populate non-collection properties from first available item");
            sb.AppendLine("            foreach (var item in items)");
            sb.AppendLine("            {");

            foreach (var property in nonCollectionProperties)
            {
                sb.AppendLine($"                if (item.TryGetValue(\"{property.AttributeName}\", out var {property.PropertyName.ToLowerInvariant()}Value))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    entity.{property.PropertyName} = {GetFromAttributeValueExpression(property, $"{property.PropertyName.ToLowerInvariant()}Value")};");
                sb.AppendLine("                }");
            }

            sb.AppendLine("                break; // Use first item for non-collection properties");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // Then, populate collection properties by grouping items
        var collectionProperties = entity.Properties.Where(p => p.IsCollection && p.HasAttributeMapping).ToArray();
        foreach (var collectionProperty in collectionProperties)
        {
            GenerateCollectionPropertyFromItems(sb, entity, collectionProperty);
        }

        // Finally, populate related entity properties based on sort key patterns
        if (entity.Relationships.Length > 0)
        {
            GenerateRelatedEntityMapping(sb, entity);
        }

        sb.AppendLine("            return (TSelf)(object)entity;");
    }

    private static void GenerateCollectionPropertyFromItems(StringBuilder sb, EntityModel entity, PropertyModel collectionProperty)
    {
        var elementType = GetCollectionElementType(collectionProperty.PropertyType);

        sb.AppendLine($"            // Populate {collectionProperty.PropertyName} collection from items");
        sb.AppendLine($"            var {collectionProperty.PropertyName.ToLowerInvariant()}List = new List<{elementType}>();");
        sb.AppendLine();

        // Filter items that contain this collection's attribute
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{collectionProperty.AttributeName}\", out var {collectionProperty.PropertyName.ToLowerInvariant()}Value))");
        sb.AppendLine("                {");

        if (IsComplexType(elementType))
        {
            // For complex types, we'd need to reconstruct the object
            sb.AppendLine($"                    // TODO: Implement complex type reconstruction for {elementType}");
            sb.AppendLine($"                    // For now, create default instance");
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = new {elementType}();");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }
        else
        {
            // For primitive types, convert directly
            sb.AppendLine($"                    var {collectionProperty.PropertyName.ToLowerInvariant()}Item = {GetFromAttributeValueExpression(new PropertyModel { PropertyType = elementType, IsNullable = false }, $"{collectionProperty.PropertyName.ToLowerInvariant()}Value")};");
            sb.AppendLine($"                    {collectionProperty.PropertyName.ToLowerInvariant()}List.Add({collectionProperty.PropertyName.ToLowerInvariant()}Item);");
        }

        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine($"            entity.{collectionProperty.PropertyName} = {collectionProperty.PropertyName.ToLowerInvariant()}List;");
        sb.AppendLine();
    }

    private static void GenerateGetPartitionKeyMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Extracts the partition key value from a DynamoDB item.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static string GetPartitionKey(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");

        var partitionKeyProperty = entity.PartitionKeyProperty;
        if (partitionKeyProperty != null)
        {
            sb.AppendLine($"            if (item.TryGetValue(\"{partitionKeyProperty.AttributeName}\", out var pkValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                return pkValue.S != null ? pkValue.S : string.Empty;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return string.Empty;");
        }
        else
        {
            sb.AppendLine("            // No partition key defined");
            sb.AppendLine("            return string.Empty;");
        }

        sb.AppendLine("        }");
    }

    private static void GenerateMatchesEntityMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Determines whether a DynamoDB item matches this entity type.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static bool MatchesEntity(Dictionary<string, AttributeValue> item)");
        sb.AppendLine("        {");

        // Check entity discriminator first if present
        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"            // Check entity discriminator");
            sb.AppendLine($"            if (item.TryGetValue(\"EntityType\", out var entityTypeValue))");
            sb.AppendLine("            {");
            sb.AppendLine($"                return entityTypeValue.S == \"{entity.EntityDiscriminator}\";");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // Use sort key pattern matching for entity type discrimination
        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty != null && !string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine("            // Check sort key pattern for entity type discrimination");
            sb.AppendLine($"            if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
            sb.AppendLine("            {");
            sb.AppendLine("                var sortKey = sortKeyValue.S != null ? sortKeyValue.S : string.Empty;");

            // Generate pattern matching based on entity discriminator
            if (entity.EntityDiscriminator.Contains("*"))
            {
                // Wildcard pattern matching
                var pattern = entity.EntityDiscriminator.Replace("*", "");
                sb.AppendLine($"                return sortKey.StartsWith(\"{pattern}\");");
            }
            else
            {
                // Exact pattern matching
                sb.AppendLine($"                return sortKey == \"{entity.EntityDiscriminator}\" || sortKey.StartsWith(\"{entity.EntityDiscriminator}#\");");
            }

            sb.AppendLine("            }");
            sb.AppendLine();
        }

        // Check if required attributes exist
        var requiredAttributes = entity.Properties
            .Where(p => p.HasAttributeMapping && (p.IsPartitionKey || !p.IsNullable))
            .ToArray();

        if (requiredAttributes.Length > 0)
        {
            sb.AppendLine("            // Check if required attributes exist");
            foreach (var property in requiredAttributes)
            {
                sb.AppendLine($"            if (!item.ContainsKey(\"{property.AttributeName}\"))");
                sb.AppendLine("                return false;");
            }
            sb.AppendLine();
        }

        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
    }

    private static void GenerateGetEntityMetadataMethod(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets metadata about the entity structure for future LINQ support.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static EntityMetadata GetEntityMetadata()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new EntityMetadata");
        sb.AppendLine("            {");
        sb.AppendLine($"                TableName = \"{entity.TableName}\",");

        if (!string.IsNullOrEmpty(entity.EntityDiscriminator))
        {
            sb.AppendLine($"                EntityDiscriminator = \"{entity.EntityDiscriminator}\",");
        }

        sb.AppendLine($"                IsMultiItemEntity = false,");
        sb.AppendLine("                Properties = new PropertyMetadata[]");
        sb.AppendLine("                {");

        // Generate property metadata
        foreach (var property in entity.Properties.Where(p => p.HasAttributeMapping))
        {
            GeneratePropertyMetadata(sb, property);
        }

        sb.AppendLine("                },");
        sb.AppendLine("                Indexes = new IndexMetadata[]");
        sb.AppendLine("                {");

        // Generate index metadata
        foreach (var index in entity.Indexes)
        {
            GenerateIndexMetadata(sb, index);
        }

        sb.AppendLine("                },");
        sb.AppendLine("                Relationships = new RelationshipMetadata[]");
        sb.AppendLine("                {");

        // Generate relationship metadata
        foreach (var relationship in entity.Relationships)
        {
            GenerateRelationshipMetadata(sb, relationship);
        }

        sb.AppendLine("                }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
    }

    private static void GeneratePropertyMetadata(StringBuilder sb, PropertyModel property)
    {
        sb.AppendLine("                    new PropertyMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{property.PropertyName}\",");
        sb.AppendLine($"                        AttributeName = \"{property.AttributeName}\",");
        sb.AppendLine($"                        PropertyType = typeof({GetTypeForMetadata(property.PropertyType)}),");
        sb.AppendLine($"                        IsPartitionKey = {property.IsPartitionKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsSortKey = {property.IsSortKey.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsCollection = {property.IsCollection.ToString().ToLowerInvariant()},");
        sb.AppendLine($"                        IsNullable = {property.IsNullable.ToString().ToLowerInvariant()},");

        // Add supported operations if available
        if (property.Queryable?.HasSupportedOperations == true)
        {
            var operations = string.Join(", ", property.Queryable.SupportedOperations.Select(op => $"DynamoDbOperation.{op}"));
            sb.AppendLine($"                        SupportedOperations = new[] {{ {operations} }},");
        }
        else
        {
            sb.AppendLine("                        SupportedOperations = Array.Empty<DynamoDbOperation>(),");
        }

        // Add available indexes if specified
        if (property.Queryable?.HasIndexRestrictions == true)
        {
            var indexes = string.Join(", ", property.Queryable.AvailableInIndexes.Select(idx => $"\"{idx}\""));
            sb.AppendLine($"                        AvailableInIndexes = new[] {{ {indexes} }},");
        }

        // Add key format if available
        if (property.KeyFormat != null)
        {
            sb.AppendLine("                        KeyFormat = new KeyFormatMetadata");
            sb.AppendLine("                        {");
            if (!string.IsNullOrEmpty(property.KeyFormat.Prefix))
            {
                sb.AppendLine($"                            Prefix = \"{property.KeyFormat.Prefix}\",");
            }
            if (property.KeyFormat.Separator != "#")
            {
                sb.AppendLine($"                            Separator = \"{property.KeyFormat.Separator}\"");
            }
            sb.AppendLine("                        }");
        }

        sb.AppendLine("                    },");
    }

    private static void GenerateIndexMetadata(StringBuilder sb, IndexModel index)
    {
        sb.AppendLine("                    new IndexMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        IndexName = \"{index.IndexName}\",");
        sb.AppendLine($"                        PartitionKeyProperty = \"{index.PartitionKeyProperty}\",");

        if (!string.IsNullOrEmpty(index.SortKeyProperty))
        {
            sb.AppendLine($"                        SortKeyProperty = \"{index.SortKeyProperty}\",");
        }

        if (index.ProjectedProperties.Length > 0)
        {
            var projectedProps = string.Join(", ", index.ProjectedProperties.Select(p => $"\"{p}\""));
            sb.AppendLine($"                        ProjectedProperties = new[] {{ {projectedProps} }},");
        }
        else
        {
            sb.AppendLine("                        ProjectedProperties = Array.Empty<string>(),");
        }

        if (!string.IsNullOrEmpty(index.PartitionKeyFormat))
        {
            sb.AppendLine($"                        KeyFormat = \"{index.PartitionKeyFormat}\"");
        }

        sb.AppendLine("                    },");
    }

    private static void GenerateRelationshipMetadata(StringBuilder sb, RelationshipModel relationship)
    {
        sb.AppendLine("                    new RelationshipMetadata");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        PropertyName = \"{relationship.PropertyName}\",");
        sb.AppendLine($"                        SortKeyPattern = \"{relationship.SortKeyPattern}\",");

        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            sb.AppendLine($"                        EntityType = typeof({relationship.EntityType}),");
        }

        sb.AppendLine($"                        IsCollection = {relationship.IsCollection.ToString().ToLowerInvariant()}");
        sb.AppendLine("                    },");
    }

    private static string GetBaseType(string typeName)
    {
        // Remove nullable annotations and generic type parameters
        var baseType = typeName.TrimEnd('?');

        // Handle nullable value types like int?, bool?, etc.
        if (baseType.StartsWith("System.Nullable<") && baseType.EndsWith(">"))
        {
            var innerType = baseType.Substring(16, baseType.Length - 17); // Remove "System.Nullable<" and ">"
            return innerType;
        }

        return baseType;
    }

    private static string GetTypeForMetadata(string typeName)
    {
        // For metadata, we need the actual type without nullable annotations
        var baseType = GetBaseType(typeName);

        // Convert common type aliases to full type names for typeof()
        return baseType switch
        {
            "string" => "string",
            "int" => "int",
            "long" => "long",
            "double" => "double",
            "float" => "float",
            "decimal" => "decimal",
            "bool" => "bool",
            "byte[]" => "byte[]",
            _ => baseType
        };
    }

    private static bool IsEnumType(string typeName)
    {
        // This is a simplified check - in a real implementation, we'd use semantic analysis
        // For now, assume any type not in our known primitives might be an enum
        var baseType = GetBaseType(typeName);
        var knownPrimitives = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double",
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid", "System.Ulid"
        };

        return !knownPrimitives.Contains(baseType) &&
               !baseType.StartsWith("System.Collections.Generic.") &&
               !baseType.StartsWith("List<") &&
               !baseType.StartsWith("IList<") &&
               !baseType.StartsWith("ICollection<") &&
               !baseType.StartsWith("IEnumerable<");
    }

    private static string GetCollectionElementType(string collectionType)
    {
        // Extract element type from collection types
        if (collectionType.StartsWith("HashSet<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(8, collectionType.Length - 9);
        }
        if (collectionType.StartsWith("System.Collections.Generic.HashSet<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(36, collectionType.Length - 37);
        }
        if (collectionType.StartsWith("List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(5, collectionType.Length - 6);
        }
        if (collectionType.StartsWith("IList<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(6, collectionType.Length - 7);
        }
        if (collectionType.StartsWith("ICollection<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("IEnumerable<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(12, collectionType.Length - 13);
        }
        if (collectionType.StartsWith("System.Collections.Generic.List<") && collectionType.EndsWith(">"))
        {
            return collectionType.Substring(33, collectionType.Length - 34);
        }

        // Default to object if we can't determine the element type
        return "object";
    }

    private static bool IsComplexType(string typeName)
    {
        var baseType = GetBaseType(typeName);
        var primitiveTypes = new[]
        {
            "string", "int", "long", "double", "float", "decimal", "bool", "DateTime", "DateTimeOffset",
            "Guid", "byte[]", "System.String", "System.Int32", "System.Int64", "System.Double",
            "System.Single", "System.Decimal", "System.Boolean", "System.DateTime", "System.DateTimeOffset",
            "System.Guid", "System.Byte[]", "Ulid", "System.Ulid", "object"
        };

        return !primitiveTypes.Contains(baseType);
    }

    private static bool IsNumericType(string typeName)
    {
        var baseType = GetBaseType(typeName);
        var numericTypes = new[]
        {
            "int", "long", "double", "float", "decimal", "byte", "short", "uint", "ulong", "ushort",
            "System.Int32", "System.Int64", "System.Double", "System.Single", "System.Decimal",
            "System.Byte", "System.Int16", "System.UInt32", "System.UInt64", "System.UInt16"
        };

        return numericTypes.Contains(baseType);
    }

    private static string GetToAttributeValueExpressionForCollectionElement(string elementType, string valueExpression)
    {
        var baseType = GetBaseType(elementType);

        return baseType switch
        {
            "string" => $"new AttributeValue {{ S = {valueExpression} }}",
            "int" or "System.Int32" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "long" or "System.Int64" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "double" or "System.Double" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "float" or "System.Single" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "decimal" or "System.Decimal" => $"new AttributeValue {{ N = {valueExpression}.ToString() }}",
            "bool" or "System.Boolean" => $"new AttributeValue {{ BOOL = {valueExpression} }}",
            "DateTime" or "System.DateTime" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "DateTimeOffset" or "System.DateTimeOffset" => $"new AttributeValue {{ S = {valueExpression}.ToString(\"O\") }}",
            "Guid" or "System.Guid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            "Ulid" or "System.Ulid" => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ when IsEnumType(elementType) => $"new AttributeValue {{ S = {valueExpression}.ToString() }}",
            _ => $"new AttributeValue {{ S = {valueExpression} != null ? {valueExpression}.ToString() : \"\" }}"
        };
    }

    private static string GetNumericConversionExpression(string numericType)
    {
        return numericType switch
        {
            "int" or "System.Int32" => "x => int.Parse(x)",
            "long" or "System.Int64" => "x => long.Parse(x)",
            "double" or "System.Double" => "x => double.Parse(x)",
            "float" or "System.Single" => "x => float.Parse(x)",
            "decimal" or "System.Decimal" => "x => decimal.Parse(x)",
            "byte" or "System.Byte" => "x => byte.Parse(x)",
            "short" or "System.Int16" => "x => short.Parse(x)",
            "uint" or "System.UInt32" => "x => uint.Parse(x)",
            "ulong" or "System.UInt64" => "x => ulong.Parse(x)",
            "ushort" or "System.UInt16" => "x => ushort.Parse(x)",
            _ => "x => x" // fallback to string
        };
    }

    private static string GetFromAttributeValueExpressionForCollectionElement(string elementType)
    {
        var baseType = GetBaseType(elementType);

        return baseType switch
        {
            "string" => "x => x.S",
            "int" or "System.Int32" => "x => int.Parse(x.N)",
            "long" or "System.Int64" => "x => long.Parse(x.N)",
            "double" or "System.Double" => "x => double.Parse(x.N)",
            "float" or "System.Single" => "x => float.Parse(x.N)",
            "decimal" or "System.Decimal" => "x => decimal.Parse(x.N)",
            "bool" or "System.Boolean" => "x => x.BOOL",
            "DateTime" or "System.DateTime" => "x => DateTime.Parse(x.S)",
            "DateTimeOffset" or "System.DateTimeOffset" => "x => DateTimeOffset.Parse(x.S)",
            "Guid" or "System.Guid" => "x => Guid.Parse(x.S)",
            "Ulid" or "System.Ulid" => "x => Ulid.Parse(x.S)",
            _ when IsEnumType(elementType) => $"x => Enum.Parse<{baseType}>(x.S)",
            _ => "x => x.S" // fallback to string
        };
    }

    private static void GenerateRelatedEntityMapping(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine("            // Populate related entity properties based on sort key patterns");

        var sortKeyProperty = entity.SortKeyProperty;
        if (sortKeyProperty == null)
        {
            sb.AppendLine("            // No sort key defined - cannot map related entities");
            return;
        }

        foreach (var relationship in entity.Relationships)
        {
            sb.AppendLine();
            sb.AppendLine($"            // Map related entity: {relationship.PropertyName}");

            if (relationship.IsCollection)
            {
                GenerateRelatedEntityCollectionMapping(sb, entity, relationship, sortKeyProperty);
            }
            else
            {
                GenerateRelatedEntitySingleMapping(sb, entity, relationship, sortKeyProperty);
            }
        }
    }

    private static void GenerateRelatedEntityCollectionMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var elementType = GetCollectionElementType(relationship.PropertyType);

        sb.AppendLine($"            var {relationship.PropertyName.ToLowerInvariant()}Items = new List<{elementType}>();");
        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S != null ? sortKeyValue.S : string.Empty;");

        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);

        sb.AppendLine("                    {");

        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            var relatedEntity = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine($"                            {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of element type
            sb.AppendLine($"                        // Generic mapping to {elementType}");
            sb.AppendLine($"                        var relatedEntity = new {elementType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {elementType}");
            sb.AppendLine($"                        {relationship.PropertyName.ToLowerInvariant()}Items.Add(relatedEntity);");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine($"            entity.{relationship.PropertyName} = {relationship.PropertyName.ToLowerInvariant()}Items;");
    }

    private static void GenerateRelatedEntitySingleMapping(StringBuilder sb, EntityModel entity, RelationshipModel relationship, PropertyModel sortKeyProperty)
    {
        var propertyType = relationship.EntityType != null ? relationship.EntityType : GetBaseType(relationship.PropertyType);

        sb.AppendLine("            foreach (var item in items)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (item.TryGetValue(\"{sortKeyProperty.AttributeName}\", out var sortKeyValue))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var sortKey = sortKeyValue.S != null ? sortKeyValue.S : string.Empty;");

        // Generate pattern matching logic
        GenerateSortKeyPatternMatching(sb, relationship.SortKeyPattern);

        sb.AppendLine("                    {");

        if (!string.IsNullOrEmpty(relationship.EntityType))
        {
            // Use specific entity type for mapping
            sb.AppendLine($"                        // Map to specific entity type: {relationship.EntityType}");
            sb.AppendLine($"                        if ({relationship.EntityType}.MatchesEntity(item))");
            sb.AppendLine("                        {");
            sb.AppendLine($"                            entity.{relationship.PropertyName} = {relationship.EntityType}.FromDynamoDb<{relationship.EntityType}>(item);");
            sb.AppendLine("                            break; // Found the related entity");
            sb.AppendLine("                        }");
        }
        else
        {
            // Generic mapping - create instance of property type
            sb.AppendLine($"                        // Generic mapping to {propertyType}");
            sb.AppendLine($"                        entity.{relationship.PropertyName} = new {propertyType}();");
            sb.AppendLine($"                        // TODO: Implement generic property mapping for {propertyType}");
            sb.AppendLine("                        break; // Found the related entity");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

    private static void GenerateSortKeyPatternMatching(StringBuilder sb, string sortKeyPattern)
    {
        if (sortKeyPattern.Contains("*"))
        {
            // Wildcard pattern matching
            var prefix = sortKeyPattern.Replace("*", "");
            sb.AppendLine($"                    if (sortKey.StartsWith(\"{prefix}\"))");
        }
        else
        {
            // Exact pattern matching
            sb.AppendLine($"                    if (sortKey == \"{sortKeyPattern}\" || sortKey.StartsWith(\"{sortKeyPattern}#\"))");
        }
    }

    private static void GenerateComputedKeyLogic(StringBuilder sb, PropertyModel computedProperty)
    {
        var computedKey = computedProperty.ComputedKey!;
        var propertyName = computedProperty.PropertyName;

        if (computedKey.HasCustomFormat)
        {
            // Use custom format string
            var formatArgs = string.Join(", ", computedKey.SourceProperties.Select(sp => $"typedEntity.{sp}"));
            sb.AppendLine($"            typedEntity.{propertyName} = string.Format(\"{computedKey.Format}\", {formatArgs});");
        }
        else
        {
            // Use separator-based concatenation
            var sourceValues = string.Join($" + \"{computedKey.Separator}\" + ", computedKey.SourceProperties.Select(sp => $"typedEntity.{sp}"));
            sb.AppendLine($"            typedEntity.{propertyName} = {sourceValues};");
        }
    }

    private static void GenerateExtractedKeyLogic(StringBuilder sb, PropertyModel extractedProperty)
    {
        var extractedKey = extractedProperty.ExtractedKey!;
        var propertyName = extractedProperty.PropertyName;
        var sourceProperty = extractedKey.SourceProperty;
        var index = extractedKey.Index;
        var separator = extractedKey.Separator;

        sb.AppendLine($"            if (!string.IsNullOrEmpty(entity.{sourceProperty}))");
        sb.AppendLine("            {");
        sb.AppendLine($"                var {sourceProperty.ToLowerInvariant()}Parts = entity.{sourceProperty}.Split('{separator}');");
        sb.AppendLine($"                if ({sourceProperty.ToLowerInvariant()}Parts.Length > {index})");
        sb.AppendLine("                {");
        sb.AppendLine($"                    entity.{propertyName} = {sourceProperty.ToLowerInvariant()}Parts[{index}];");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
    }

}