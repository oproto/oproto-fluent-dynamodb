using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates table class implementations with method-based builder access.
/// </summary>
public static class TableGenerator
{
    /// <summary>
    /// Generates a table class implementation for an entity.
    /// </summary>
    /// <param name="entity">The entity model to generate a table for.</param>
    /// <returns>The generated table class code.</returns>
    public static string GenerateTableClass(EntityModel entity)
    {
        // Skip generation for nested entities (DynamoDbEntity)
        var isNestedEntity = entity.TableName?.StartsWith("_entity_") == true;
        if (isNestedEntity)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        
        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        
        // Usings
        sb.AppendLine("using Amazon.DynamoDBv2;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Logging;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Requests;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Requests.Extensions;");
        sb.AppendLine("using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine();
        
        // Namespace
        sb.AppendLine($"namespace {entity.Namespace};");
        sb.AppendLine();
        
        // Class declaration
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated table class for {entity.ClassName} entity.");
        sb.AppendLine($"/// Provides method-based access to DynamoDB operations.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public partial class {entity.ClassName}Table : DynamoDbTableBase");
        sb.AppendLine("{");
        
        // Constructors
        GenerateConstructors(sb, entity);
        
        // Get/Update/Delete overloads based on key structure
        GenerateOperationOverloads(sb, entity);
        
        // Index properties
        GenerateIndexProperties(sb, entity);
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateConstructors(StringBuilder sb, EntityModel entity)
    {
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the {entity.ClassName}Table.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"client\">The DynamoDB client.</param>");
        sb.AppendLine($"    public {entity.ClassName}Table(IAmazonDynamoDB client)");
        sb.AppendLine($"        : base(client, \"{entity.TableName}\")");
        sb.AppendLine($"    {{");
        sb.AppendLine($"    }}");
        sb.AppendLine();
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the {entity.ClassName}Table with a logger.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"client\">The DynamoDB client.</param>");
        sb.AppendLine($"    /// <param name=\"logger\">Logger for DynamoDB operations.</param>");
        sb.AppendLine($"    public {entity.ClassName}Table(IAmazonDynamoDB client, IDynamoDbLogger logger)");
        sb.AppendLine($"        : base(client, \"{entity.TableName}\", logger)");
        sb.AppendLine($"    {{");
        sb.AppendLine($"    }}");
        sb.AppendLine();
    }

    private static void GenerateOperationOverloads(StringBuilder sb, EntityModel entity)
    {
        var partitionKey = entity.PartitionKeyProperty;
        var sortKey = entity.SortKeyProperty;
        
        if (partitionKey == null)
        {
            // No partition key - shouldn't happen for valid tables, but handle gracefully
            return;
        }

        var pkAttributeName = partitionKey.AttributeName;
        var pkPropertyType = GetCSharpType(partitionKey.PropertyType);
        
        if (sortKey == null)
        {
            // Single partition key table
            GenerateSingleKeyOverloads(sb, entity, pkAttributeName, pkPropertyType);
        }
        else
        {
            // Composite key table
            var skAttributeName = sortKey.AttributeName;
            var skPropertyType = GetCSharpType(sortKey.PropertyType);
            GenerateCompositeKeyOverloads(sb, entity, pkAttributeName, pkPropertyType, skAttributeName, skPropertyType);
        }
    }

    private static void GenerateSingleKeyOverloads(StringBuilder sb, EntityModel entity, string pkAttributeName, string pkPropertyType)
    {
        var paramName = ToCamelCase(pkAttributeName);
        
        // Get overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets an item by its {pkAttributeName} (partition key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{paramName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>A GetItemRequestBuilder configured with the key.</returns>");
        sb.AppendLine($"    public GetItemRequestBuilder Get({pkPropertyType} {paramName}) =>");
        sb.AppendLine($"        base.Get().WithKey(\"{pkAttributeName}\", {paramName});");
        sb.AppendLine();
        
        // Update overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Updates an item by its {pkAttributeName} (partition key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{paramName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>An UpdateItemRequestBuilder configured with the key.</returns>");
        sb.AppendLine($"    public UpdateItemRequestBuilder Update({pkPropertyType} {paramName}) =>");
        sb.AppendLine($"        base.Update().WithKey(\"{pkAttributeName}\", {paramName});");
        sb.AppendLine();
        
        // Delete overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Deletes an item by its {pkAttributeName} (partition key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{paramName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>A DeleteItemRequestBuilder configured with the key.</returns>");
        sb.AppendLine($"    public DeleteItemRequestBuilder Delete({pkPropertyType} {paramName}) =>");
        sb.AppendLine($"        base.Delete().WithKey(\"{pkAttributeName}\", {paramName});");
        sb.AppendLine();
    }

    private static void GenerateCompositeKeyOverloads(StringBuilder sb, EntityModel entity, 
        string pkAttributeName, string pkPropertyType, string skAttributeName, string skPropertyType)
    {
        var pkParamName = ToCamelCase(pkAttributeName);
        var skParamName = ToCamelCase(skAttributeName);
        
        // Get overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets an item by its {pkAttributeName} (partition key) and {skAttributeName} (sort key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{pkParamName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <param name=\"{skParamName}\">The {skAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>A GetItemRequestBuilder configured with the composite key.</returns>");
        sb.AppendLine($"    public GetItemRequestBuilder Get({pkPropertyType} {pkParamName}, {skPropertyType} {skParamName}) =>");
        sb.AppendLine($"        base.Get().WithKey(\"{pkAttributeName}\", {pkParamName}, \"{skAttributeName}\", {skParamName});");
        sb.AppendLine();
        
        // Update overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Updates an item by its {pkAttributeName} (partition key) and {skAttributeName} (sort key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{pkParamName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <param name=\"{skParamName}\">The {skAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>An UpdateItemRequestBuilder configured with the composite key.</returns>");
        sb.AppendLine($"    public UpdateItemRequestBuilder Update({pkPropertyType} {pkParamName}, {skPropertyType} {skParamName}) =>");
        sb.AppendLine($"        base.Update().WithKey(\"{pkAttributeName}\", {pkParamName}, \"{skAttributeName}\", {skParamName});");
        sb.AppendLine();
        
        // Delete overload
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Deletes an item by its {pkAttributeName} (partition key) and {skAttributeName} (sort key).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    /// <param name=\"{pkParamName}\">The {pkAttributeName} value.</param>");
        sb.AppendLine($"    /// <param name=\"{skParamName}\">The {skAttributeName} value.</param>");
        sb.AppendLine($"    /// <returns>A DeleteItemRequestBuilder configured with the composite key.</returns>");
        sb.AppendLine($"    public DeleteItemRequestBuilder Delete({pkPropertyType} {pkParamName}, {skPropertyType} {skParamName}) =>");
        sb.AppendLine($"        base.Delete().WithKey(\"{pkAttributeName}\", {pkParamName}, \"{skAttributeName}\", {skParamName});");
        sb.AppendLine();
    }

    private static void GenerateIndexProperties(StringBuilder sb, EntityModel entity)
    {
        if (entity.Indexes.Length == 0)
        {
            return;
        }

        foreach (var index in entity.Indexes)
        {
            var indexPropertyName = index.IndexName.Replace("-", "").Replace("_", "");
            
            // Build projection expression from properties
            var projectionExpression = BuildProjectionExpression(entity, index);
            
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Global Secondary Index: {index.IndexName}");
            sb.AppendLine($"    /// Partition Key: {index.PartitionKeyProperty}");
            if (index.HasSortKey)
            {
                sb.AppendLine($"    /// Sort Key: {index.SortKeyProperty}");
            }
            sb.AppendLine($"    /// </summary>");
            
            if (!string.IsNullOrEmpty(projectionExpression))
            {
                sb.AppendLine($"    public DynamoDbIndex {indexPropertyName} =>");
                sb.AppendLine($"        new DynamoDbIndex(this, \"{index.IndexName}\", \"{projectionExpression}\");");
            }
            else
            {
                sb.AppendLine($"    public DynamoDbIndex {indexPropertyName} =>");
                sb.AppendLine($"        new DynamoDbIndex(this, \"{index.IndexName}\");");
            }
            sb.AppendLine();
        }
    }

    private static string BuildProjectionExpression(EntityModel entity, IndexModel index)
    {
        // If projected properties are specified, use them
        if (index.ProjectedProperties.Length > 0)
        {
            return string.Join(", ", index.ProjectedProperties);
        }

        // Otherwise, build from entity properties that are part of this index
        var projectedProps = new List<string>();
        
        // Always include keys
        var pkProp = entity.Properties.FirstOrDefault(p => p.PropertyName == index.PartitionKeyProperty);
        if (pkProp != null && !string.IsNullOrEmpty(pkProp.AttributeName))
        {
            projectedProps.Add(pkProp.AttributeName);
        }
        
        if (index.HasSortKey)
        {
            var skProp = entity.Properties.FirstOrDefault(p => p.PropertyName == index.SortKeyProperty);
            if (skProp != null && !string.IsNullOrEmpty(skProp.AttributeName))
            {
                projectedProps.Add(skProp.AttributeName);
            }
        }
        
        // Add table keys if not already included
        if (entity.PartitionKeyProperty != null && !string.IsNullOrEmpty(entity.PartitionKeyProperty.AttributeName))
        {
            if (!projectedProps.Contains(entity.PartitionKeyProperty.AttributeName))
            {
                projectedProps.Add(entity.PartitionKeyProperty.AttributeName);
            }
        }
        
        if (entity.SortKeyProperty != null && !string.IsNullOrEmpty(entity.SortKeyProperty.AttributeName))
        {
            if (!projectedProps.Contains(entity.SortKeyProperty.AttributeName))
            {
                projectedProps.Add(entity.SortKeyProperty.AttributeName);
            }
        }
        
        return string.Join(", ", projectedProps);
    }

    private static string GetCSharpType(string propertyType)
    {
        // Remove nullable annotation for parameter types
        return propertyType.TrimEnd('?');
    }

    private static string ToCamelCase(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;
        
        // Handle snake_case
        if (text.Contains('_'))
        {
            var parts = text.Split('_');
            return string.Concat(parts.Select((part, index) => 
                index == 0 ? part.ToLowerInvariant() : Capitalize(part)));
        }
        
        // Handle kebab-case
        if (text.Contains('-'))
        {
            var parts = text.Split('-');
            return string.Concat(parts.Select((part, index) => 
                index == 0 ? part.ToLowerInvariant() : Capitalize(part)));
        }
        
        // Handle PascalCase
        if (char.IsUpper(text[0]))
        {
            return char.ToLowerInvariant(text[0]) + text.Substring(1);
        }
        
        return text;
    }

    private static string Capitalize(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;
        
        return char.ToUpperInvariant(text[0]) + text.Substring(1).ToLowerInvariant();
    }
}
