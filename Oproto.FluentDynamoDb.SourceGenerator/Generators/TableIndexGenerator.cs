using Microsoft.CodeAnalysis;
using Oproto.FluentDynamoDb.SourceGenerator.Diagnostics;
using Oproto.FluentDynamoDb.SourceGenerator.Models;
using System.Text;

namespace Oproto.FluentDynamoDb.SourceGenerator.Generators;

/// <summary>
/// Generates index properties on table classes for Global Secondary Indexes.
/// </summary>
internal static class TableIndexGenerator
{
    private static readonly List<Diagnostic> _diagnostics = new();
    /// <summary>
    /// Gets the diagnostics collected during generation.
    /// </summary>
    public static IReadOnlyList<Diagnostic> Diagnostics => _diagnostics;
    
    /// <summary>
    /// Generates index properties for all GSIs defined across entities.
    /// Creates generic DynamoDbIndex&lt;TProjection&gt; if UseProjection is specified,
    /// otherwise creates non-generic DynamoDbIndex.
    /// </summary>
    /// <param name="tableName">The table name.</param>
    /// <param name="entities">The entities that belong to this table.</param>
    /// <param name="projectionModels">The projection models available for this table.</param>
    /// <returns>The generated C# source code for the table partial class with index properties.</returns>
    public static string GenerateIndexProperties(
        string tableName,
        IEnumerable<EntityModel> entities,
        IEnumerable<ProjectionModel> projectionModels)
    {
        _diagnostics.Clear();
        var entityList = entities.ToList();
        if (entityList.Count == 0)
            return string.Empty;

        // Group GSI definitions by index name
        var gsiDefinitions = GroupGsiDefinitions(entityList, projectionModels);
        
        if (gsiDefinitions.Count == 0)
            return string.Empty;

        // Use the first entity's namespace for the table class
        var firstEntity = entityList.First();
        var tableClassName = GetTableClassName(tableName);
        
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This code was generated by the DynamoDB Source Generator.");
        sb.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        sb.AppendLine();
        sb.AppendLine($"namespace {firstEntity.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine("    using Oproto.FluentDynamoDb.Storage;");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Partial class for {tableClassName} with auto-generated GSI index properties.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public partial class {tableClassName}");
        sb.AppendLine("    {");
        
        // Generate a property for each unique GSI
        foreach (var gsiDef in gsiDefinitions.Values)
        {
            GenerateIndexProperty(sb, gsiDef);
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    /// <summary>
    /// Groups GSI definitions by index name across multiple entities.
    /// Detects [UseProjection] attributes and resolves projection expressions.
    /// </summary>
    private static Dictionary<string, GsiDefinition> GroupGsiDefinitions(
        List<EntityModel> entities,
        IEnumerable<ProjectionModel> projectionModels)
    {
        var gsiDefinitions = new Dictionary<string, GsiDefinition>();
        var projectionLookup = projectionModels.ToDictionary(p => p.ClassName, p => p);

        foreach (var entity in entities)
        {
            foreach (var index in entity.Indexes)
            {
                if (!gsiDefinitions.TryGetValue(index.IndexName, out var gsiDef))
                {
                    gsiDef = new GsiDefinition
                    {
                        IndexName = index.IndexName,
                        PartitionKeyProperty = index.PartitionKeyProperty,
                        SortKeyProperty = index.SortKeyProperty
                    };
                    gsiDefinitions[index.IndexName] = gsiDef;
                }

                // Add entity type to the list
                if (!gsiDef.EntityTypes.Contains(entity.ClassName))
                {
                    gsiDef.EntityTypes.Add(entity.ClassName);
                }

                // Check for [UseProjection] attribute on the partition key property
                var partitionKeyProp = entity.Properties.FirstOrDefault(p => p.PropertyName == index.PartitionKeyProperty);
                if (partitionKeyProp != null)
                {
                    var useProjectionType = DetectUseProjectionAttribute(partitionKeyProp);
                    if (useProjectionType != null)
                    {
                        // Validate that the projection type exists (PROJ005)
                        if (!projectionLookup.ContainsKey(useProjectionType))
                        {
                            var location = partitionKeyProp.PropertyDeclaration?.GetLocation();
                            ReportDiagnostic(
                                DiagnosticDescriptors.UseProjectionInvalidType,
                                location,
                                index.IndexName,
                                useProjectionType);
                        }
                        
                        // Set projection type if not already set
                        if (gsiDef.ProjectionType == null)
                        {
                            gsiDef.ProjectionType = useProjectionType;
                            
                            // Resolve projection expression from projection model
                            if (projectionLookup.TryGetValue(useProjectionType, out var projectionModel))
                            {
                                gsiDef.ProjectionExpression = projectionModel.ProjectionExpression;
                            }
                        }
                        else if (gsiDef.ProjectionType != useProjectionType)
                        {
                            // PROJ006: Multiple entities have conflicting [UseProjection] attributes for the same GSI
                            var location = partitionKeyProp.PropertyDeclaration?.GetLocation();
                            ReportDiagnostic(
                                DiagnosticDescriptors.ConflictingUseProjection,
                                location,
                                index.IndexName);
                        }
                    }
                }
            }
        }

        return gsiDefinitions;
    }
    
    /// <summary>
    /// Reports a diagnostic message.
    /// </summary>
    private static void ReportDiagnostic(DiagnosticDescriptor descriptor, Location? location, params object[] messageArgs)
    {
        var diagnostic = Diagnostic.Create(descriptor, location ?? Location.None, messageArgs);
        _diagnostics.Add(diagnostic);
    }

    /// <summary>
    /// Detects [UseProjection] attribute on a property and returns the projection type name.
    /// </summary>
    private static string? DetectUseProjectionAttribute(PropertyModel property)
    {
        if (property.PropertyDeclaration == null || property.PropertyDeclaration.Parent?.Parent == null)
            return null;

        // Look for UseProjection attribute in the property's attribute lists
        foreach (var attributeList in property.PropertyDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var attributeName = attribute.Name.ToString();
                if (attributeName.Contains("UseProjection"))
                {
                    // Extract the type argument from typeof(...)
                    if (attribute.ArgumentList?.Arguments.FirstOrDefault()?.Expression is Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax typeOfExpr)
                    {
                        return typeOfExpr.Type.ToString();
                    }
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Generates a single index property.
    /// If projection is specified, generates DynamoDbIndex&lt;TProjection&gt;.
    /// Otherwise generates non-generic DynamoDbIndex.
    /// </summary>
    private static void GenerateIndexProperty(StringBuilder sb, GsiDefinition gsiDef)
    {
        var propertyName = gsiDef.IndexName;
        
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Gets the {gsiDef.IndexName} Global Secondary Index.");
        
        if (gsiDef.EntityTypes.Count > 0)
        {
            sb.AppendLine($"        /// Used by: {string.Join(", ", gsiDef.EntityTypes)}");
        }
        
        if (gsiDef.ProjectionType != null)
        {
            sb.AppendLine($"        /// Projection: {gsiDef.ProjectionType}");
        }
        
        sb.AppendLine($"        /// </summary>");
        
        if (gsiDef.ProjectionType != null)
        {
            // Generate generic DynamoDbIndex<TProjection> with projection expression
            sb.Append($"        public DynamoDbIndex<{gsiDef.ProjectionType}> {propertyName} => ");
            sb.Append($"new DynamoDbIndex<{gsiDef.ProjectionType}>(");
            sb.Append($"this, \"{gsiDef.IndexName}\"");
            
            if (!string.IsNullOrEmpty(gsiDef.ProjectionExpression))
            {
                sb.Append($", \"{gsiDef.ProjectionExpression}\"");
            }
            
            sb.AppendLine(");");
        }
        else
        {
            // Generate non-generic DynamoDbIndex without projection
            sb.AppendLine($"        public DynamoDbIndex {propertyName} => new DynamoDbIndex(this, \"{gsiDef.IndexName}\");");
        }
    }

    /// <summary>
    /// Converts a table name to a table class name.
    /// Example: "my-table" -> "MyTable"
    /// </summary>
    private static string GetTableClassName(string tableName)
    {
        // Simple conversion: capitalize first letter and remove hyphens
        var parts = tableName.Split('-', '_');
        var className = string.Join("", parts.Select(p => 
            p.Length > 0 ? char.ToUpper(p[0]) + p.Substring(1) : p));
        
        return className + "Table";
    }
}
