name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  validate-tag:
    name: Validate Tag and Extract Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      release-notes: ${{ steps.extract.outputs.release-notes }}
      is-prerelease: ${{ steps.extract.outputs.is-prerelease }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract and validate version
        id: extract
        run: |
          # Extract version from tag (remove 'v' prefix)
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG_NAME#v}"
          
          echo "Tag: $TAG_NAME"
          echo "Version: $VERSION"
          
          # Validate semantic version format
          SEMVER_REGEX='^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-((0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*))*))?(\+([0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*))?$'
          
          if ! echo "$VERSION" | grep -qE "$SEMVER_REGEX"; then
            echo "âŒ Invalid version tag format: $TAG_NAME"
            echo "Expected format: v{MAJOR}.{MINOR}.{PATCH}[-{PRERELEASE}]"
            echo "Examples: v1.0.0, v2.1.3-beta.1, v1.0.0-rc.1"
            exit 1
          fi
          
          echo "âœ… Version format is valid"
          
          # Check if this is a pre-release
          if echo "$VERSION" | grep -q '-'; then
            echo "is-prerelease=true" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Pre-release version detected"
          else
            echo "is-prerelease=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Stable release version detected"
          fi
          
          # Check if CHANGELOG.md exists
          if [ ! -f "CHANGELOG.md" ]; then
            echo "âŒ CHANGELOG.md not found in repository root"
            exit 1
          fi
          
          # Check if CHANGELOG.md contains section for this version
          if ! grep -q "## \[$VERSION\]" CHANGELOG.md; then
            echo "âŒ Changelog entry not found for version $VERSION"
            echo "Please add a section in CHANGELOG.md:"
            echo "## [$VERSION] - $(date +%Y-%m-%d)"
            exit 1
          fi
          
          echo "âœ… Changelog entry found for version $VERSION"
          
          # Extract release notes from changelog
          # Find the section for this version and extract until the next version section
          RELEASE_NOTES=$(awk "/## \[$VERSION\]/,/## \[/" CHANGELOG.md | sed '1d;$d' | sed '/^$/d')
          
          if [ -z "$RELEASE_NOTES" ]; then
            echo "âš ï¸  Warning: Release notes are empty for version $VERSION"
            RELEASE_NOTES="Release $VERSION"
          fi
          
          # Save outputs
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Save release notes to a file to handle multiline content
          echo "$RELEASE_NOTES" > /tmp/release-notes.txt
          {
            echo 'release-notes<<EOF'
            cat /tmp/release-notes.txt
            echo EOF
          } >> $GITHUB_OUTPUT
          
          echo "âœ… Version validation complete"
          echo "Version: $VERSION"
          echo "Pre-release: $(echo "$VERSION" | grep -q '-' && echo 'Yes' || echo 'No')"

  build-packages:
    name: Build NuGet Packages
    runs-on: ubuntu-latest
    needs: validate-tag
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup .NET 8.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build all projects
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          echo "Building with version: $VERSION"
          
          # Build all projects with the same version
          # This ensures ProjectReferences will use the correct version when packed
          dotnet build \
            --configuration Release \
            --no-restore \
            /maxcpucount:1 \
            -p:Version=$VERSION \
            -p:PackageVersion=$VERSION \
            -p:AssemblyVersion=$VERSION \
            -p:FileVersion=$VERSION \
            -p:InformationalVersion=$VERSION
      
      - name: Pack NuGet packages
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          echo "Packing version: $VERSION"
          
          # Pack all packable projects
          # Don't use --no-build to ensure version is applied correctly
          # ProjectReferences will automatically become PackageReferences with matching versions
          dotnet pack Oproto.FluentDynamoDb/Oproto.FluentDynamoDb.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.BlobStorage.S3/Oproto.FluentDynamoDb.BlobStorage.S3.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.Encryption.Kms/Oproto.FluentDynamoDb.Encryption.Kms.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.FluentResults/Oproto.FluentDynamoDb.FluentResults.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.Logging.Extensions/Oproto.FluentDynamoDb.Logging.Extensions.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.NewtonsoftJson/Oproto.FluentDynamoDb.NewtonsoftJson.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
          
          dotnet pack Oproto.FluentDynamoDb.SystemTextJson/Oproto.FluentDynamoDb.SystemTextJson.csproj \
            --configuration Release \
            --output ./packages \
            -p:Version=$VERSION
      
      - name: Validate package dependencies
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          echo "ðŸ“¦ Validating package dependencies for version: $VERSION"
          
          # Check packages with dependencies on Oproto.FluentDynamoDb
          for pkg in BlobStorage.S3 Encryption.Kms FluentResults Logging.Extensions; do
            PACKAGE_FILE="./packages/Oproto.FluentDynamoDb.${pkg}.${VERSION}.nupkg"
            if [ -f "$PACKAGE_FILE" ]; then
              echo "Checking $pkg package..."
              unzip -q -o "$PACKAGE_FILE" -d "./temp-${pkg}"
              
              # Extract and check the nuspec file for dependency version
              NUSPEC_FILE="./temp-${pkg}/Oproto.FluentDynamoDb.${pkg}.nuspec"
              if [ -f "$NUSPEC_FILE" ] && grep -q "Oproto.FluentDynamoDb" "$NUSPEC_FILE"; then
                DEP_VERSION=$(grep -A 1 'id="Oproto.FluentDynamoDb"' "$NUSPEC_FILE" | grep version | sed 's/.*version="\([^"]*\)".*/\1/' || echo "not-found")
                echo "  Found dependency: Oproto.FluentDynamoDb version $DEP_VERSION"
                
                if [ "$DEP_VERSION" != "$VERSION" ] && [ "$DEP_VERSION" != "not-found" ]; then
                  echo "  âŒ ERROR: Dependency version mismatch! Expected $VERSION but got $DEP_VERSION"
                  exit 1
                elif [ "$DEP_VERSION" = "$VERSION" ]; then
                  echo "  âœ… Dependency version matches: $VERSION"
                fi
              fi
              
              rm -rf "./temp-${pkg}"
            fi
          done
          
          echo "âœ… All package dependencies validated"
      
      - name: Validate package contents
        run: |
          echo "ðŸ“¦ Validating package contents..."
          
          for package in ./packages/*.nupkg; do
            if [ -f "$package" ]; then
              echo "Checking: $(basename $package)"
              
              # Extract package to temp directory
              TEMP_DIR=$(mktemp -d)
              unzip -q "$package" -d "$TEMP_DIR"
              
              # Check for DLL files
              if ! find "$TEMP_DIR" -name "*.dll" | grep -q .; then
                echo "âŒ No DLL files found in $(basename $package)"
                exit 1
              fi
              
              # Check for XML documentation files
              if ! find "$TEMP_DIR" -name "*.xml" | grep -q .; then
                echo "âš ï¸  Warning: No XML documentation found in $(basename $package)"
              fi
              
              # Clean up
              rm -rf "$TEMP_DIR"
              
              echo "âœ… $(basename $package) validated"
            fi
          done
          
          echo "âœ… All packages validated successfully"
      
      - name: Generate package manifest
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          COMMIT_SHA="${GITHUB_SHA}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "Generating package manifest..."
          
          # Start JSON
          cat > ./packages/package-manifest.json << EOF
          {
            "version": "$VERSION",
            "tag": "v$VERSION",
            "commit": "$COMMIT_SHA",
            "buildDate": "$BUILD_DATE",
            "packages": [
          EOF
          
          # Add package entries
          FIRST=true
          for package in ./packages/*.nupkg; do
            if [ -f "$package" ]; then
              PACKAGE_NAME=$(basename "$package")
              PACKAGE_ID=$(echo "$PACKAGE_NAME" | sed "s/\.$VERSION\.nupkg//")
              PACKAGE_SIZE=$(stat -f%z "$package" 2>/dev/null || stat -c%s "$package")
              PACKAGE_SHA256=$(sha256sum "$package" | awk '{print $1}')
              
              # Find corresponding symbols package
              SYMBOLS_FILE="${package%.nupkg}.snupkg"
              SYMBOLS_NAME=""
              if [ -f "$SYMBOLS_FILE" ]; then
                SYMBOLS_NAME=$(basename "$SYMBOLS_FILE")
              fi
              
              # Add comma if not first entry
              if [ "$FIRST" = false ]; then
                echo "," >> ./packages/package-manifest.json
              fi
              FIRST=false
              
              # Add package entry
              cat >> ./packages/package-manifest.json << ENTRY
                {
                  "id": "$PACKAGE_ID",
                  "version": "$VERSION",
                  "file": "$PACKAGE_NAME",
                  "symbolsFile": "$SYMBOLS_NAME",
                  "size": $PACKAGE_SIZE,
                  "sha256": "$PACKAGE_SHA256"
                }
          ENTRY
            fi
          done
          
          # Close JSON
          cat >> ./packages/package-manifest.json << EOF
          
            ]
          }
          EOF
          
          echo "âœ… Package manifest generated"
          cat ./packages/package-manifest.json
      
      - name: Upload packages
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: ./packages/
          retention-days: 90
          if-no-files-found: error

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-tag, build-packages]
    
    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./packages
      
      - name: List downloaded packages
        run: |
          echo "ðŸ“¦ Downloaded packages:"
          ls -lh ./packages/
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: Release v${{ needs.validate-tag.outputs.version }}
          body: ${{ needs.validate-tag.outputs.release-notes }}
          prerelease: ${{ needs.validate-tag.outputs.is-prerelease }}
          files: |
            ./packages/*.nupkg
            ./packages/*.snupkg
            ./packages/package-manifest.json
          fail_on_unmatched_files: false
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Release summary
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          IS_PRERELEASE="${{ needs.validate-tag.outputs.is-prerelease }}"
          
          echo "# ðŸŽ‰ Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** $([ "$IS_PRERELEASE" = "true" ] && echo "Pre-release" || echo "Stable Release")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“¦ Packages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          for package in ./packages/*.nupkg; do
            if [ -f "$package" ]; then
              PACKAGE_NAME=$(basename "$package")
              PACKAGE_SIZE=$(stat -f%z "$package" 2>/dev/null || stat -c%s "$package")
              PACKAGE_SIZE_MB=$(echo "scale=2; $PACKAGE_SIZE / 1024 / 1024" | bc)
              echo "- \`$PACKAGE_NAME\` (${PACKAGE_SIZE_MB} MB)" >> $GITHUB_STEP_SUMMARY
            fi
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“ Release Notes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.validate-tag.outputs.release-notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— [View Release](https://github.com/${{ github.repository }}/releases/tag/v$VERSION)" >> $GITHUB_STEP_SUMMARY
